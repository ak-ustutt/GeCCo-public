*----------------------------------------------------------------------*
      subroutine split_contr4(contr_rem,contr_spl,contr,op_info,
     &                        ok,debug)
*----------------------------------------------------------------------*
*     given a contraction contr and a contraction contr_spl (which
*     must be contained in contr, check with contr_in_contr()!),
*     obtain the remainder on contr_rem
*
*     new version: aditional connectivity information is stored via
*      xarcs 
*     more stable identification of the proper sub-contraction
*     (i.pt. if several similar operators are present which only
*      differ by topology)
*
*     note that the contractions should all be in canonical order
*     (automatically, if generated by gen_contrX).
*
*     half way towards new treatment with topo-matrices
*
*----------------------------------------------------------------------*
      implicit none

      include 'opdim.h'
      include 'stdunit.h'
      include 'def_contraction.h'
      include 'mdef_operator_info.h'
      include 'ifc_operators.h'

      integer, parameter ::
     &     ntest = 00

      type(contraction), intent(in) ::
     &     contr, contr_spl
      type(contraction), intent(out) ::
     &     contr_rem

      type(operator_info), intent(in) ::
     &     op_info
      logical, intent(out) ::
     &     ok
      logical, intent(in) ::
     &     debug

      logical ::
     &     success, check, conn, trsp
      integer ::
     &     nvtx, nvtx_spl, nvtx_rem, nvtx_test,
     &     narc, narc_spl, narc_rem,
     &     nxarc,nxarc_spl,nxarc_rem,
     &     ivtx_spl, ivtx_rem, ivtx1, ivtx2, nj, nj_spl, ispl,
     &     iarc, ixarc, iarc_rem, ixarc_rem, lenlist, lenlist2,
     &     ivtx, jvtx, kvtx, lvtx, idx,
     &     sh_sign, icnt, occ_x(ngastp,2), occ_cnt(ngastp,2), nskip,
     &     isvtx, ij, ij0, ij_spl, idum, cnt, cnt_trp, ij_found
      integer(8) ::
     &     base
      integer, pointer ::
     &     ivtx_new(:), ivtx_new0(:), isupervtx_spl(:), vtxmap_i(:),
     &     vtxmap(:), ireo(:), ireo_i(:),
     &     svertex(:), svertex_spl(:),
     &     list(:), list2(:), ivtx_tmp(:), isuper_tgt(:),
     &     spl_map(:,:), spl_nxarc4vtx(:),
     &     spl_conn(:,:), spl_nconn4vtx(:),
     &     spl_map_c(:,:), spl_nxarc4vtx_c(:)
      integer(8), pointer ::
     &     topo(:,:), topo_spl(:,:), vtx(:), vtx_spl(:),
     &     topo_sv(:,:), ixrc_map(:,:),
     &     xlines(:,:), xlines_spl(:,:)

      integer, external ::
     &     njres_contr, int8_expand, idxlist

      base = pack_base
      ok = .true.

      if (debug.and.ntest.ge.100) then
        call write_title(lulog,wst_dbg_subr,'split_contr4 at work')
        write(lulog,*) 'contr:'
        call prt_contr2(lulog,contr,op_info)
        write(lulog,*) 'contr_spl:'
        call prt_contr2(lulog,contr_spl,op_info)
      end if

      ! prefactor
      if (abs(contr_spl%fac).lt.1d-100)
     &     call quit(1,'split_contr4','division by zero encountered')
      contr_rem%fac = contr%fac / contr_spl%fac

      nvtx = contr%nvtx
      nvtx_spl = contr_spl%nvtx
      narc = contr%narc
      narc_spl = contr_spl%narc
      nxarc = contr%nxarc
      nxarc_spl = contr_spl%nxarc

      allocate(ivtx_new0(nvtx),ivtx_new(nvtx))

      !nj = njres_contr(contr)
      !nj_spl = njres_contr(contr_spl) ! does not always work
      nj     = op_info%op_arr(contr%idx_res)%op%njoined
      nj_spl = op_info%op_arr(contr_spl%idx_res)%op%njoined
      if (debug.and.ntest.ge.100) 
     &              write(lulog,*) 'nj, nj_spl: ',nj, nj_spl

      allocate(vtxmap(nvtx),vtxmap_i(nvtx),
     &         vtx(nvtx),topo(nvtx,nvtx),xlines(nvtx,nj),
     &         vtx_spl(nvtx_spl),topo_spl(nvtx_spl,nvtx_spl),
     &         xlines_spl(nvtx_spl,nj_spl),
     &         ireo(nvtx),ireo_i(nvtx),
     &         list(2*nvtx*nvtx),list2(2*nvtx*nvtx),svertex(nvtx),
     &         svertex_spl(nvtx_spl))

      call pack_contr(svertex,vtx,topo,xlines,contr,nj)
      call pack_contr(svertex_spl,vtx_spl,topo_spl,xlines_spl,
     &                                        contr_spl,nj_spl)

      nskip = 0
      do
        call identify_vertices_i8(vtxmap,success,nskip,
     &                       svertex_spl,vtx_spl,topo_spl,nvtx_spl,
     &                       svertex,vtx,topo,nvtx)

        ! also check that connecting contractions are contained in xlines of A
        if (success) then
          call contr_in_xlines(vtxmap,success,
     &                        xlines_spl,nvtx_spl,nj_spl,
     &                        topo,nvtx)
        else
          exit
        end if

        if (success) exit
        nskip = nskip + 1
      end do

      if (debug.and.ntest.ge.200) then
        write(lulog,'("ABC:")')
        call prt_contr_p(lulog,svertex,vtx,topo,
     &       xlines,nvtx,nj)
        write(lulog,'("B:")')
        call prt_contr_p(lulog,svertex_spl,vtx_spl,topo_spl,
     &       xlines_spl,nvtx_spl,nj_spl)
      end if
      
      if (.not.success) then
        write(lulog,'("ABC:")')
        call prt_contr_p(lulog,svertex,vtx,topo,
     &       xlines,nvtx,nj)
        write(lulog,'("B:")')
        call prt_contr_p(lulog,svertex_spl,vtx_spl,topo_spl,
     &       xlines_spl,nvtx_spl,nj_spl)
        call quit(1,'split_contr4',
     &     'contractions do not match; check with contr_in_contr() '//
     &     'before call to split_contr3()')
      end if

      ! vtxmap contains vtxmap(oldvtx) = vtx_on_spl
      ! get inverted map vtxmap_i(vtx_on_spl) = oldvtx
      vtxmap_i = 0
      do ivtx = 1, nvtx
        if (vtxmap(ivtx).gt.0)
     &       vtxmap_i(vtxmap(ivtx)) = ivtx
      end do

      if (debug.and.ntest.ge.100)
     &     write(lulog,'(1x,a,10i3)') 'vtxmap:   ',vtxmap
      if (debug.and.ntest.ge.100)
     &     write(lulog,'(1x,a,10i3)') 'vtxmap_i: ',vtxmap_i


      ! assemble a list of all vertices in contr that belong to
      ! contr_spl:
      list = 0
      lenlist = 0
      do ivtx = 1, nvtx
        if (vtxmap(ivtx)==0) cycle
        lenlist = lenlist+1
        list(lenlist) = ivtx
      end do

      if (debug.and.ntest.ge.100)
     &    write(lulog, '(1x,a,10(1x,2i3))') 'list: ',list(1:lenlist)
      
      ! move contr_spl vertices together to avoid ambiguities in the
      ! placement of the "0" nodes and their connectivity
      ! new order on ireo:  ireo(oldvtx) = newvtx
      do ivtx = 1, nvtx
         ireo(ivtx) = ivtx
      end do
      sh_sign = 1

      ! go over the list and set up new lists with vertices belonging to the same contr_spl supervertex
      do ij = 1, nj_spl
         lenlist2 = 0
         do idx = 1, lenlist
            if (xlines_spl(vtxmap(list(idx)),ij).gt.0) then
               lenlist2 = lenlist2+1
               list2(lenlist2) = list(idx)
            end if
         end do
         if (lenlist2.gt.1) then
           if (debug.and.ntest.ge.100)
     &         write(lulog, '(1x,a,20(i3))') 'list2: ',
     &                                        list2(1:lenlist2)
           call topo_approach_vtxs(ireo,sh_sign,
     &       svertex,vtx,topo,xlines,
     &       nvtx,nj,list2,lenlist2)
           exit ! TODO: I currently cannot do this more than once
         end if
      end do
      if (debug.and.ntest.ge.200) then
        write(lulog,'("After topo_approach_vtxs:")')
        write(lulog,'("sh_sign:",i4)') sh_sign
        call prt_contr_p(lulog,svertex,vtx,topo,
     &       xlines,nvtx,nj)
      end if
c
      ! ireo(oldvtx) = newvtx
      ! inverted reordering array:
      ! ireo_i(newvtx) = oldvtx
      do ivtx = 1, nvtx
        ireo_i(ireo(ivtx)) = ivtx
      end do

      if (debug.and.ntest.ge.100)
     &     write(lulog, '(1x,a,10i3)') 'ireo:  ',ireo
      if (debug.and.ntest.ge.100)
     &     write(lulog, '(1x,a,10i3)') 'ireo_i: ',ireo_i
      
      ! now remove all contracted indices of contr_spl
      ! get list of all contractions of contr_spl
      lenlist = 0
      list = 0
      do ivtx = 1, nvtx
        if (vtxmap(ireo_i(ivtx)).eq.0) cycle
        do jvtx = ivtx, nvtx  ! no harm but it could be ivtx+1, I think
          if (vtxmap(ireo_i(jvtx)).eq.0) cycle
          lenlist = lenlist+1
          list(1+(lenlist-1)*2) = ivtx
          list(2+(lenlist-1)*2) = jvtx
        end do
      end do

      if (debug.and.ntest.ge.100)
     &     write(lulog, '(1x,a,10(1x,2i3))') 'list: ',list(1:lenlist*2)

      ! remove contractions of contr_spl vertices
      ! no sign control required here
      call topo_remove_arcs(topo,nvtx,list,lenlist)

      if (debug.and.ntest.ge.200) then
        write(lulog,'("After topo_remove_arcs:")')
        call prt_contr_p(lulog,svertex,vtx,topo,
     &       xlines,nvtx,nj)
      end if
      
c      lenlist = lenlist*2
c      call unique_list(list,lenlist)

      ! set: reo
      !      vtxmap
      ! xlines_spl will be destroyed
      allocate(ixrc_map(nvtx,nvtx))
      ixrc_map = 0
      do ivtx = 1, nvtx
        do jvtx = ivtx+1, nvtx
          cnt = topo(ireo(ivtx),ireo(jvtx))
          cnt_trp = topo(ireo(jvtx),ireo(ivtx))   ! transpose of the above, if req.d
          if (cnt==0) cycle         ! no contraction
          if (vtxmap(ivtx)==0.and.vtxmap(jvtx)==0) cycle  ! purely non spl contraction
          ! note: a pure spl contraction is imposs. due to topo_remove_arcs
          ! which spl vertex does it belongs to
          ivtx_spl = max(vtxmap(ivtx),vtxmap(jvtx)) ! get the non-zero one
          trsp = vtxmap(jvtx).ne.0                  ! if 2nd was non-zero, we have to transpose xline
          occ_cnt = 0
          icnt = int8_expand(cnt,base,occ_cnt)
          if (debug.and.ntest.ge.300) then
            write(lulog,'(1x,"ivtx,jvtx,reo(ivtx),reo(jvtx)",4i4)')
     &           ivtx,jvtx,ireo(ivtx),ireo(jvtx)
            write(lulog,'(1x,"ivtx_spl,cnt,trsp",i4,i10,x,l)')
     &           ivtx_spl,cnt,trsp
            call wrt_occ(lulog,occ_cnt)
          end if
          ! check overlap with corresp. xline
          ij_loop: do ij = 1, nj_spl
            if (debug.and.ntest.ge.300) write(lulog,'(4x,"ij:",i4,i10)')
     &           ij, xlines_spl(ivtx_spl,ij)
            if (xlines_spl(ivtx_spl,ij).ne.0) then
              occ_x = 0          
              icnt = int8_expand(xlines_spl(ivtx_spl,ij),base,occ_x)
              if (debug.and.ntest.ge.300) then
                write(lulog,'(4x,">ij:",i4,2x,l)')
     &               ij,iocc_bound('<=',occ_cnt,.false.,occ_x,trsp)
                call wrt_occ(lulog,occ_x)
              end if
              if (iocc_bound('<=',occ_cnt,.false.,occ_x,trsp)) then
                ixrc_map(ivtx,jvtx) = ij  
                if (trsp) then  ! decrease xlines_spl to avoid double counting
                  xlines_spl(ivtx_spl,ij) = xlines_spl(ivtx_spl,ij)
     &                                      - cnt_trp
                else
                  xlines_spl(ivtx_spl,ij) = xlines_spl(ivtx_spl,ij)
     &                                      - cnt
                end if
                exit ij_loop
              else if (iocc_bound('<=',occ_x,trsp,occ_cnt,.false.)) then
                ok = .false. ! give up --- to be improved
                goto 9999
              end if
            end if
          end do ij_loop
        end do
      end do

      if (debug.and.ntest.ge.100) then
        write(lulog,'(1x,"ixrc_map:")')
        do ivtx = 1, nvtx
          write(lulog,'(1x,20i4)') ixrc_map(ivtx,1:nvtx)
        end do
      end if
        
      
      if (sh_sign.ne.1) then
        if (debug.and.ntest.ge.100) write(lulog,*) 'sign change!'
        contr_rem%fac = -contr_rem%fac
      end if

      ! make sure that isupervtx_spl(1) is set
      
      ! use reo and vtxmap to build ivtx_new
      ! the vertices belonging to the spl are indicated by negative numbers
      ! use spl_map_c here
      ivtx_rem = 0
      ij_spl = 0
      ivtx_new0 = 0
      do ivtx = 1, nvtx
        ! loop over reordered vertices to better identify positions for split
        kvtx = ireo_i(ivtx)
        if (vtxmap(kvtx).eq.0) then  ! zero: keep this vertex
c dbg
c           write(lulog,'(a,3i4)') '>> processing ivtx, kvtx, vtxmap:',
c     &              ivtx, kvtx, vtxmap(kvtx)
c dbg
          ! does any spl contract from above?
          ij_found = 0
          do jvtx = 1, nvtx
            lvtx = ireo_i(jvtx)
            if (lvtx.ge.kvtx) cycle
            ij_found = max(ij_found,ixrc_map(lvtx,kvtx))
c dbg
c            write(lulog,'(a,3i4)') '  -- looking at',
c     &             lvtx,kvtx,ixrc_map(lvtx,kvtx)
c dbg
          end do
          ij0 = ij_spl+1
c dbg
c          write(lulog,'(a,2i4)') 'ij0, ij_found: ',ij0, ij_found
c dbg
          do ij = ij0, ij_found
            ij_spl = ij_spl+1
            ivtx_rem = ivtx_rem+1
            if (ivtx_rem.gt.nvtx) call quit(1,'split_contr4','trap A')
            ivtx_new0(ivtx_rem) = -ij
          end do
          ivtx_rem = ivtx_rem+1
          if (ivtx_rem.gt.nvtx) call quit(1,'split_contr4','trap B')
          ivtx_new0(ivtx_rem) = kvtx
        else 
          ! anything to do?
        end if
      end do
      
      ! append any missing split vertices here
      ij0 = ij_spl+1
      do isvtx = ij0, nj_spl
        ij_spl = ij_spl+1
        ivtx_rem = ivtx_rem+1
        if (ivtx_rem.gt.nvtx) call quit(1,'split_contr4','trap C')
        ivtx_new0(ivtx_rem) = -ij_spl
      end do

      nvtx_rem = ivtx_rem
      if (debug.and.ntest.ge.100) then
        write(lulog,*) 'nvtx_rem: ',nvtx_rem
        write(lulog,'(1x,a,10i3)') 'ivtx_new0: ',
     &       ivtx_new0(1:nvtx_rem)
      end if

      ivtx_new = 0
      do ivtx = 1, nvtx_rem
        if (ivtx_new0(ivtx).gt.0) 
     &       ivtx_new(ivtx_new0(ivtx)) = ivtx
      end do

      if (debug.and.ntest.ge.100) then
        write(lulog,'(1x,a,10i3)') 'ivtx_new:  ',
     &       ivtx_new(1:nvtx)
      end if

c      call quit(1,'split_contr4','test exit')


      ! what we intend to have at this point:
      !  - ivtx_new(oldvtx) should contain the new vertex position or <=0 if this is now a 0 vertex
      !  - vtxmap(oldvtx) should contain the vertex number in contr_spl
      !  - ixrc_map(oldvtx1,oldvtx2) should contain the supervertex number of the result
      !    operator of contr_spl to which the former contraction between oldvtx1 and oldvtx2
      !    contributed.
      
      ! loop over arcs of contr and get number of new arcs
      narc_rem  = 0
      do iarc = 1, narc
        ivtx1 = contr%arc(iarc)%link(1)
        ivtx2 = contr%arc(iarc)%link(2)
        if (ivtx_new(ivtx1).le.0.and.ivtx_new(ivtx2).le.0) cycle
        narc_rem = narc_rem+1
      end do

      nxarc_rem = nxarc
      do ixarc = 1, nxarc
        ivtx1 = contr%xarc(ixarc)%link(1)
        if (ivtx_new(ivtx1).le.0) nxarc_rem = nxarc_rem - 1
      end do

      ! resize contr_rem
      call resize_contr(contr_rem,nvtx_rem,narc_rem,nxarc_rem,0)

c      write(lulog,*) '>>>>>>>>>>>>>> nvtx_rem  = ',nvtx_rem
c      write(lulog,*) '>>>>>>>>>>>>>> narc_rem  = ',narc_rem
c      write(lulog,*) '>>>>>>>>>>>>>> nxarc_rem = ',nxarc_rem

      contr_rem%nvtx = nvtx_rem
      contr_rem%narc = narc_rem
      contr_rem%nxarc = nxarc_rem

      ! keep this info:
      contr_rem%idx_res = contr%idx_res
      contr_rem%iblk_res = contr%iblk_res

      ! ------------
      ! set vertices
      ! ------------
      do ivtx = 1, nvtx_rem
        ivtx_rem = ivtx_new0(ivtx)
        if (ivtx_rem.gt.0) then
          contr_rem%vertex(ivtx) = contr%vertex(ivtx_rem)
          contr_rem%svertex(ivtx) = contr%svertex(ivtx_rem)
        else
          contr_rem%vertex(ivtx)%idx_op = 0
          contr_rem%vertex(ivtx)%iblk_op = 0
          contr_rem%svertex(ivtx) = 100
        end if
      end do

      ! ---------
      ! set arcs
      ! ---------

      iarc_rem = 0
      do iarc = 1, narc
        ivtx1 = contr%arc(iarc)%link(1)
        ivtx2 = contr%arc(iarc)%link(2)
        if (ivtx_new(ivtx1).le.0.and.ivtx_new(ivtx2).le.0) cycle
        iarc_rem = iarc_rem+1
        if (iarc_rem.gt.narc_rem)
     &       call quit(1,'split_contr4','na sowas ...!?!')
        if (ivtx_new(ivtx1).gt.0) then
          contr_rem%arc(iarc_rem)%link(1) = ivtx_new(ivtx1)
        else
          contr_rem%arc(iarc_rem)%link(1) = -ixrc_map(ivtx1,ivtx2) 
        end if
        if (ivtx_new(ivtx2).gt.0) then
          contr_rem%arc(iarc_rem)%link(2) = ivtx_new(ivtx2)
        else
          contr_rem%arc(iarc_rem)%link(2) = -ixrc_map(ivtx1,ivtx2) 
        end if
        contr_rem%arc(iarc_rem)%occ_cnt = contr%arc(iarc)%occ_cnt
      end do

      ! ---------
      ! set xarcs
      ! ---------
      ! copy the remaining xarcs
      ixarc_rem = 0
      do ixarc = 1, nxarc
        ivtx1 = contr%xarc(ixarc)%link(1)
        ivtx2 = contr%xarc(ixarc)%link(2)
        if (ivtx_new(ivtx1).le.0) cycle
        ixarc_rem = ixarc_rem+1
        if (ixarc_rem.gt.nxarc_rem)
     &       call quit(1,'split_contr4','ja, wie denn ...!?!')
        contr_rem%xarc(ixarc_rem)%link(1) = ivtx_new(ivtx1)
        contr_rem%xarc(ixarc_rem)%link(2) = ivtx2 !?!
        contr_rem%xarc(ixarc_rem)%occ_cnt = contr%xarc(ixarc)%occ_cnt
      end do

      ! add the new xarcs
c      do iarc = 1, narc
c        ivtx1 = contr%arc(iarc)%link(1)
c        ivtx2 = contr%arc(iarc)%link(2)
c        if (ivtx_new(ivtx1).eq.0.and.ivtx_new(ivtx2).eq.0) cycle
c        if (ivtx_new(ivtx1).ne.0.and.ivtx_new(ivtx2).ne.0) cycle
c
c        call quit(1,'split_contr4','test exit')
c        ixarc_rem = ixarc_rem+1
c        if (ixarc_rem.gt.nxarc_rem)
c     &       call quit(1,'split_contr4','ja, was denn ...!?!')
c        if (ivtx_new(ivtx1).ne.0) then
c          contr_rem%xarc(ixarc_rem)%link(1) = ivtx_new(ivtx1)
cc          contr_rem%xarc(ixarc_rem)%link(2) = -isupervtx_spl(ivtx2)
c          contr_rem%xarc(ixarc_rem)%occ_cnt = contr%arc(iarc)%occ_cnt
c        else
c          contr_rem%xarc(ixarc_rem)%link(1) = ivtx_new(ivtx2)
cc          contr_rem%xarc(ixarc_rem)%link(2) = -isupervtx_spl(ivtx1)
c          contr_rem%xarc(ixarc_rem)%occ_cnt =
c     &         iocc_dagger(contr%arc(iarc)%occ_cnt)
c        end if
c
c      end do

      call update_svtx4contr(contr_rem)

      call contr_clean_arcs(contr_rem%arc,contr_rem%narc)
      call arc_sort(contr_rem%arc,contr_rem%narc,contr_rem%nvtx)
      call contr_clean_arcs(contr_rem%xarc,contr_rem%nxarc)
      call arc_sort(contr_rem%xarc,contr_rem%nxarc,contr_rem%nvtx)

c     deallocate(topo,topo_spl,vtx,vtx_spl,xlines,xlines_spl,ireo,ireo_i,
c     &       svertex,svertex_spl,list,ivtx_new,ivtx_new0,vtxmap,
c     &       spl_nxarc4vtx,spl_map,topo_sv)
 9999 deallocate(ixrc_map)
      deallocate(vtxmap,vtxmap_i,
     &         vtx,topo,xlines,
     &         vtx_spl,topo_spl,
     &         xlines_spl,
     &         ireo,ireo_i,
     &         list,list2,svertex,
     &         svertex_spl)
      deallocate(ivtx_new0,ivtx_new)

      if (debug.and.ntest.ge.100) then
        if (ok) then
          write(lulog,*) 'final contr_rem:'
          call prt_contr2(lulog,contr_rem,op_info)
        else
          write(lulog,*) 'giving up'
        end if
      end if

      return
      end
