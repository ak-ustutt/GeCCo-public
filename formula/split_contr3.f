*----------------------------------------------------------------------*
      subroutine split_contr3(contr_rem,contr_spl,contr,op_info)
*----------------------------------------------------------------------*
*     given a contraction contr and a contraction contr_spl (which
*     must be contained in contr, check with contr_in_contr()!),
*     obtain the remainder on contr_rem
*
*     new version: aditional connectivity information is stored via
*      xarcs 
*     more stable identification of the proper sub-contraction
*     (i.pt. if several similar operators are present which only
*      differ by topology)
*
*     note that the contractions should all be in canonical order
*     (automatically, if generated by gen_contrX).
*
*     half way towards new treatment with topo-matrices
*
*----------------------------------------------------------------------*
      implicit none

      include 'opdim.h'
      include 'stdunit.h'
      include 'def_contraction.h'
      include 'mdef_operator_info.h'
      include 'ifc_operators.h'

      integer, parameter ::
     &     ntest = 00

      type(contraction), intent(in) ::
     &     contr, contr_spl
      type(contraction), intent(out) ::
     &     contr_rem

      type(operator_info), intent(in) ::
     &     op_info

      logical ::
     &     success
      integer ::
     &     nvtx, nvtx_spl, nvtx_rem, ivtx_spl_last, isupervtx_spl_last,
     &     narc, narc_spl, narc_rem,
     &     nxarc,nxarc_spl,nxarc_rem, nvtx_test,
     &     ivtx_spl, ivtx_rem, ivtx, ivtx1, ivtx2, nj, nj_spl,
     &     iarc, ixarc, iarc_rem, ixarc_rem, lenlist, jvtx, ij,
     &     isuper_spl_last, sh_sign
      integer, pointer ::
     &     ivtx_new(:), isupervtx_spl(:),
     &     vtxmap(:), ireo(:), ireo2(:), svertex(:), svertex_spl(:),
     &     list(:)
      integer(8), pointer ::
     &     topo(:,:), topo_spl(:,:), vtx(:), vtx_spl(:),
     &     xlines(:,:), xlines_spl(:,:)

      integer, external ::
     &     ifndmax, maxblk_in_contr, njres_contr

      if (ntest.ge.100) then
        call write_title(luout,wst_dbg_subr,'split_contr2 at work')
        write(luout,*) 'contr:'
        call prt_contr2(luout,contr,op_info)
        write(luout,*) 'contr_spl:'
        call prt_contr2(luout,contr_spl,op_info)
      end if

      ! prefactor
      if (abs(contr_spl%fac).lt.1d-100)
     &     call quit(1,'split_contr','division by zero encountered')
      contr_rem%fac = contr%fac / contr_spl%fac

      nvtx = contr%nvtx
      nvtx_spl = contr_spl%nvtx
      narc = contr%narc
      narc_spl = contr_spl%narc
      nxarc = contr%nxarc
      nxarc_spl = contr_spl%nxarc

      allocate(ivtx_new(nvtx),isupervtx_spl(nvtx))

      nj = njres_contr(contr)
      nj_spl = njres_contr(contr_spl)

      allocate(vtxmap(nvtx),
     &         vtx(nvtx),topo(nvtx,nvtx),xlines(nvtx,nj),
     &         vtx_spl(nvtx_spl),topo_spl(nvtx_spl,nvtx_spl),
     &         xlines_spl(nvtx_spl,nj_spl),ireo(nvtx),ireo2(nvtx),
     &         list(2*nvtx*nvtx),svertex(nvtx),
     &         svertex_spl(nvtx_spl))

      call pack_contr(svertex,vtx,topo,xlines,contr,nj)
      call pack_contr(svertex_spl,vtx_spl,topo_spl,xlines_spl,
     &                                        contr_spl,nj_spl)

      call identify_vertices_i8(vtxmap,success,
     &                       vtx_spl,topo_spl,nvtx_spl,
     &                       vtx,topo,nvtx)

      if (.not.success) then
        call prt_contr_p(luout,svertex,vtx,topo,
     &       xlines,nvtx,nj)
        call prt_contr_p(luout,svertex_spl,vtx_spl,topo_spl,
     &       xlines_spl,nvtx_spl,nj_spl)
        call quit(1,'split_contr3',
     &     'contractions do not match; check with contr_in_contr() '//
     &     'before call to split_contr2()')
      end if

      lenlist = 0
      do ivtx = 1, nvtx
        if (vtxmap(ivtx).eq.0) cycle
        do jvtx = ivtx, nvtx
          if (vtxmap(jvtx).eq.0) cycle
          lenlist = lenlist+1
          list(1+(lenlist-1)*2) = ivtx
          list(2+(lenlist-1)*2) = jvtx
        end do
      end do
        
      call topo_remove_arcs(topo,nvtx,list,lenlist)
        
      lenlist = lenlist*2
      call unique_list(list,lenlist)

      call topo_approach_vtxs(ireo,sh_sign,
     &       svertex,vtx,topo,xlines,
     &       nvtx,nj,list,lenlist)

      if (sh_sign.ne.1) then
c dbg
        print *,'sh_sign in split: ',sh_sign
c dbg
        contr_rem%fac = -contr_rem%fac
      end if
c dbg
c      print *,'after approach:'
c      call prt_contr_p(luout,svertex,vtx,topo,
c     &       xlines,nvtx,nj)
c dbg
c      do ivtx = 1, nvtx
c        list_reo(ivtx) = ireo(list(ivtx))
c      end do

c      ! resort list
c      call unique_list(list_reo,lenlist)
c
c      call topo_merge_vtxs(ireo2,nvtx_rem,nvtx_test,
c     &                     topo,xlines,nvtx,nj,
c     &                     list_reo,lenlist)

      if (ntest.eq.100)
     &     write(luout, *) 'vtxmap: ',vtxmap
c dbg
c      call prt_contr_p(luout,svertex_spl,vtx_spl,topo_spl,
c     &       xlines_spl,nvtx_spl,nj_spl)
c dbg

      ivtx_spl = 0
      isupervtx_spl(1:nvtx) = 0
      do ivtx = 1, nvtx
        if (vtxmap(ivtx).gt.0) then
          ivtx_spl = ivtx_spl+1
          do ij = 1, nj_spl
            if (xlines_spl(ivtx_spl,ij).gt.0) then
              if (isupervtx_spl(ivtx).gt.0)
     &             call quit(1,'split_contr3','trap: xlines_spl')
              isupervtx_spl(ivtx) = ij
c              vtxmap(ivtx) = ij
            end if
          end do
        end if
      end do

      ! one exception for: single vertex, no external lines:
      ! make sure that isupervtx_spl(1) is set
      if (nvtx_spl.eq.1) isupervtx_spl(1) = 1

c      if (ntest.eq.100)
c     &     write(luout, *) 'vtxmap (new): ',vtxmap
      if (ntest.eq.100)
     &     write(luout, *) 'ireo: ',ireo
      if (ntest.eq.100)
     &     write(luout, *) 'isupervtx_spl: ',isupervtx_spl

      do ivtx = 1, nvtx
        ireo2(ireo(ivtx)) = ivtx
      end do

      if (ntest.eq.100)
     &     write(luout, *) 'ireo2: ',ireo2

      ! use reo and vtxmap to build ivtx_new
      ! use xlines_spl to set isuper_spl 
      ivtx_rem = 0
      ivtx_spl_last = -1
      isuper_spl_last = -1
      do ivtx = 1, nvtx
        jvtx = ireo2(ivtx)
        if (vtxmap(jvtx).gt.0) then
          if (isupervtx_spl(jvtx).gt.isuper_spl_last .and.
     &         isuper_spl_last.ne.0) then
            ivtx_rem = ivtx_rem+1
            ivtx_new(jvtx) = -ivtx_rem
            isuper_spl_last = vtxmap(jvtx)
            ivtx_spl_last = ivtx_rem
          else
            ivtx_new(jvtx) = -ivtx_spl_last
          end if
        else
          ivtx_rem = ivtx_rem + 1
          ivtx_new(jvtx) = ivtx_rem
        end if
      end do

      nvtx_rem = ivtx_rem
     
      if (ntest.eq.100)
     &     write(luout, *) 'ivtx_new: ',ivtx_new
      

      if (ntest.ge.100) then
        write(luout,*) 'nvtx_rem: ',nvtx_rem
        write(luout,*) 'ivtx_new (new): ',ivtx_new(1:nvtx)
        write(luout,*) 'isupervtx_spl: ',isupervtx_spl(1:nvtx)
      end if
      
      ! loop over arcs of contr and get number of new arcs
      narc_rem  = 0
      do iarc = 1, narc
        ivtx1 = contr%arc(iarc)%link(1)
        ivtx2 = contr%arc(iarc)%link(2)
        if (ivtx_new(ivtx1).lt.0.and.ivtx_new(ivtx2).lt.0) cycle
        narc_rem = narc_rem+1
      end do

      nxarc_rem = nxarc
      do ixarc = 1, nxarc
        ivtx1 = contr%xarc(ixarc)%link(1)
        if (ivtx_new(ivtx1).lt.0) nxarc_rem = nxarc_rem - 1
      end do

      ! resize contr_rem
      call resize_contr(contr_rem,nvtx_rem,narc_rem,nxarc_rem,0)

      contr_rem%nvtx = nvtx_rem
      contr_rem%narc = narc_rem
      contr_rem%nxarc = nxarc_rem

      ! keep this info:
      contr_rem%idx_res = contr%idx_res
      contr_rem%iblk_res = contr%iblk_res

      ! ------------
      ! set vertices
      ! ------------
      do ivtx = 1, nvtx
        ivtx_rem = ivtx_new(ivtx)
        if (ivtx_rem.gt.0) then
          contr_rem%vertex(ivtx_rem) = contr%vertex(ivtx)
          contr_rem%svertex(ivtx_rem) = contr%svertex(ivtx)
        else
          ivtx_rem = -ivtx_rem
          contr_rem%vertex(ivtx_rem)%idx_op = 0
          contr_rem%vertex(ivtx_rem)%iblk_op = 0
          contr_rem%svertex(ivtx_rem) = 100
        end if
      end do

      ! ---------
      ! set arcs
      ! ---------
      iarc_rem = 0
      do iarc = 1, narc
        ivtx1 = contr%arc(iarc)%link(1)
        ivtx2 = contr%arc(iarc)%link(2)
        if (ivtx_new(ivtx1).lt.0.and.ivtx_new(ivtx2).lt.0) cycle
        iarc_rem = iarc_rem+1
        if (iarc_rem.gt.narc_rem)
     &       call quit(1,'split_contr2','na sowas ...!?!')
        if (ivtx_new(ivtx1).gt.0) then
          contr_rem%arc(iarc_rem)%link(1) = ivtx_new(ivtx1)
        else
          contr_rem%arc(iarc_rem)%link(1) = -isupervtx_spl(ivtx1)
        end if
        if (ivtx_new(ivtx2).gt.0) then
          contr_rem%arc(iarc_rem)%link(2) = ivtx_new(ivtx2)
        else
          contr_rem%arc(iarc_rem)%link(2) = -isupervtx_spl(ivtx2)
        end if
        contr_rem%arc(iarc_rem)%occ_cnt = contr%arc(iarc)%occ_cnt
      end do

      ! ---------
      ! set xarcs
      ! ---------
      ! copy the remaining xarcs
      ixarc_rem = 0
      do ixarc = 1, nxarc
        ivtx1 = contr%xarc(ixarc)%link(1)
        ivtx2 = contr%xarc(ixarc)%link(2)
        if (ivtx_new(ivtx1).lt.0) cycle
        ixarc_rem = ixarc_rem+1
        if (ixarc_rem.gt.nxarc_rem)
     &       call quit(1,'split_contr2','ja, wie denn ...!?!')
        contr_rem%xarc(ixarc_rem)%link(1) = ivtx_new(ivtx1)
        contr_rem%xarc(ixarc_rem)%link(2) = ivtx2 !?!
        contr_rem%xarc(ixarc_rem)%occ_cnt = contr%xarc(ixarc)%occ_cnt
      end do

      ! add the new xarcs
      do iarc = 1, narc
        ivtx1 = contr%arc(iarc)%link(1)
        ivtx2 = contr%arc(iarc)%link(2)
        if (ivtx_new(ivtx1).eq.0.and.ivtx_new(ivtx2).eq.0) cycle
        if (ivtx_new(ivtx1).ne.0.and.ivtx_new(ivtx2).ne.0) cycle
        ixarc_rem = ixarc_rem+1
        if (ixarc_rem.gt.nxarc_rem)
     &       call quit(1,'split_contr2','ja, was denn ...!?!')
        if (ivtx_new(ivtx1).ne.0) then
          contr_rem%xarc(ixarc_rem)%link(1) = ivtx_new(ivtx1)
          contr_rem%xarc(ixarc_rem)%link(2) = -isupervtx_spl(ivtx2)
          contr_rem%xarc(ixarc_rem)%occ_cnt = contr%arc(iarc)%occ_cnt
        else
          contr_rem%xarc(ixarc_rem)%link(1) = ivtx_new(ivtx2)
          contr_rem%xarc(ixarc_rem)%link(2) = -isupervtx_spl(ivtx1)
          contr_rem%xarc(ixarc_rem)%occ_cnt =
     &         iocc_dagger(contr%arc(iarc)%occ_cnt)
        end if

      end do

      call update_svtx4contr(contr_rem)

      call contr_clean_arcs(contr_rem%arc,contr_rem%narc)
      call arc_sort(contr_rem%arc,contr_rem%narc,contr_rem%nvtx)
c dbg fix by mh
      if (associated(contr_rem%xarc)) then
c dbg original
      call contr_clean_arcs(contr_rem%xarc,contr_rem%nxarc)
      call arc_sort(contr_rem%xarc,contr_rem%nxarc,contr_rem%nvtx)
c dbg resume fix
      end if
c dbg end fix

      deallocate(topo,topo_spl,vtx,vtx_spl,xlines,xlines_spl,ireo,ireo2,
     &       svertex,svertex_spl,list,ivtx_new,isupervtx_spl,vtxmap)

      if (ntest.ge.100) then
        write(luout,*) 'final contr_rem:'
        call prt_contr2(luout,contr_rem,op_info)
      end if

      return
      end
