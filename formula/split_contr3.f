*----------------------------------------------------------------------*
      subroutine split_contr3(contr_rem,contr_spl,contr,op_info,ok)
*----------------------------------------------------------------------*
*     given a contraction contr and a contraction contr_spl (which
*     must be contained in contr, check with contr_in_contr()!),
*     obtain the remainder on contr_rem
*
*     new version: aditional connectivity information is stored via
*      xarcs 
*     more stable identification of the proper sub-contraction
*     (i.pt. if several similar operators are present which only
*      differ by topology)
*
*     note that the contractions should all be in canonical order
*     (automatically, if generated by gen_contrX).
*
*     half way towards new treatment with topo-matrices
*
*----------------------------------------------------------------------*
      implicit none

      include 'opdim.h'
      include 'stdunit.h'
      include 'def_contraction.h'
      include 'mdef_operator_info.h'
      include 'ifc_operators.h'

      integer, parameter ::
     &     ntest = 00

      type(contraction), intent(in) ::
     &     contr, contr_spl
      type(contraction), intent(out) ::
     &     contr_rem

      type(operator_info), intent(in) ::
     &     op_info
      logical, intent(out) ::
     &     ok

      logical ::
     &     success, split_vtxs
      integer ::
     &     nvtx, nvtx_spl, nvtx_rem, ivtx_spl_last, isupervtx_spl_last,
     &     narc, narc_spl, narc_rem,
     &     nxarc,nxarc_spl,nxarc_rem, nvtx_test,
     &     ivtx_spl, ivtx_rem, ivtx, ivtx1, ivtx2, nj, nj_spl,
     &     iarc, ixarc, iarc_rem, ixarc_rem, lenlist, jvtx, ij, kvtx,
     &     isuper_spl_last, sh_sign, icnt, occ_x(ngastp,2), ivtx3, nskip
      integer(8) ::
     &     base
      integer, pointer ::
     &     ivtx_new(:), isupervtx_spl(:),
     &     vtxmap(:), ireo(:), ireo2(:), svertex(:), svertex_spl(:),
     &     list(:), ivtx_tmp(:), isuper_tgt(:)
      integer(8), pointer ::
     &     topo(:,:), topo_spl(:,:), vtx(:), vtx_spl(:),
     &     xlines(:,:), xlines_spl(:,:)

      integer, external ::
     &     ifndmax, maxblk_in_contr, njres_contr, int8_expand,
     &     imltlist, idxlist

      base = pack_base
      ok = .true.

      if (ntest.ge.100) then
        call write_title(lulog,wst_dbg_subr,'split_contr3 at work')
        write(lulog,*) 'contr:'
        call prt_contr2(lulog,contr,op_info)
        write(lulog,*) 'contr_spl:'
        call prt_contr2(lulog,contr_spl,op_info)
      end if

      ! prefactor
      if (abs(contr_spl%fac).lt.1d-100)
     &     call quit(1,'split_contr3','division by zero encountered')
      contr_rem%fac = contr%fac / contr_spl%fac

      nvtx = contr%nvtx
      nvtx_spl = contr_spl%nvtx
      narc = contr%narc
      narc_spl = contr_spl%narc
      nxarc = contr%nxarc
      nxarc_spl = contr_spl%nxarc

      allocate(ivtx_new(nvtx),isupervtx_spl(nvtx),isuper_tgt(nvtx))

      nj = njres_contr(contr)
      nj_spl = njres_contr(contr_spl)

      allocate(vtxmap(nvtx),
     &         vtx(nvtx),topo(nvtx,nvtx),xlines(nvtx,nj),
     &         vtx_spl(nvtx_spl),topo_spl(nvtx_spl,nvtx_spl),
     &         xlines_spl(nvtx_spl,nj_spl),ireo(nvtx),ireo2(nvtx),
     &         list(2*nvtx*nvtx),svertex(nvtx),
     &         svertex_spl(nvtx_spl))

      call pack_contr(svertex,vtx,topo,xlines,contr,nj)
      call pack_contr(svertex_spl,vtx_spl,topo_spl,xlines_spl,
     &                                        contr_spl,nj_spl)

      nskip = 0
      do
        call identify_vertices_i8(vtxmap,success,nskip,
     &                       svertex_spl,vtx_spl,topo_spl,nvtx_spl,
     &                       svertex,vtx,topo,nvtx)

        ! also check that connecting contractions are contained in xlines of A
        if (success) then
          call contr_in_xlines(vtxmap,success,
     &                        xlines_spl,nvtx_spl,nj_spl,
     &                        topo,nvtx)
        else
          exit
        end if

        if (success) exit
        nskip = nskip + 1
      end do

      if (.not.success) then
        call prt_contr_p(lulog,svertex,vtx,topo,
     &       xlines,nvtx,nj)
        call prt_contr_p(lulog,svertex_spl,vtx_spl,topo_spl,
     &       xlines_spl,nvtx_spl,nj_spl)
        call quit(1,'split_contr3',
     &     'contractions do not match; check with contr_in_contr() '//
     &     'before call to split_contr3()')
      end if

      lenlist = 0
      do ivtx = 1, nvtx
        if (vtxmap(ivtx).eq.0) cycle
        do jvtx = ivtx, nvtx
          if (vtxmap(jvtx).eq.0) cycle
          lenlist = lenlist+1
          list(1+(lenlist-1)*2) = ivtx
          list(2+(lenlist-1)*2) = jvtx
        end do
      end do
        
      call topo_remove_arcs(topo,nvtx,list,lenlist)
        
      lenlist = lenlist*2
      call unique_list(list,lenlist)

      if (ntest.eq.100)
     &     write(lulog, *) 'vtxmap: ',vtxmap

      ivtx_spl = 0
      isupervtx_spl(1:nvtx) = 0
      split_vtxs = .false.
      do ivtx = 1, nvtx
        if (vtxmap(ivtx).gt.0) then
          ivtx_spl = vtxmap(ivtx) !ivtx_spl+1
          do ij = 1, nj_spl
            if (xlines_spl(ivtx_spl,ij).gt.0) then
cmh              if (isupervtx_spl(ivtx).gt.0)
cmh     &             call quit(1,'split_contr3','trap: xlines_spl')
              split_vtxs = split_vtxs.or.isupervtx_spl(ivtx).gt.0
              isupervtx_spl(ivtx) = ij
cmh begin     ! allow splitting of vertices (but as little as possible)
              if (ij.ge.ivtx_spl) exit
cmh end
c              vtxmap(ivtx) = ij
            end if
          end do
        end if
      end do

      ! quick fix: middle zero vertex would not be accounted for:
      if (nj_spl.eq.3.and.
     &    isupervtx_spl(idxlist(3,vtxmap,nvtx,1)).eq.3
     &    .and.isupervtx_spl(idxlist(2,vtxmap,nvtx,1)).eq.0)
     &      split_vtxs = .true.

      if (split_vtxs) then
        sh_sign = 1
        do ivtx = 1, nvtx
          ireo(ivtx) = ivtx ! split_vtxs and reorder currently not allowed
          if (vtxmap(ivtx).gt.0.and.isupervtx_spl(ivtx).eq.0) then
            ivtx_spl = vtxmap(ivtx)
            if (ivtx_spl.le.nj_spl.and.
     &          imltlist(ivtx_spl,isupervtx_spl,nvtx,1).eq.0) then
              isupervtx_spl(ivtx) = ivtx_spl ! account for zero vertices
            end if
          end if
        end do
      else      
        call topo_approach_vtxs(ireo,sh_sign,
     &       svertex,vtx,topo,xlines,
     &       nvtx,nj,list,lenlist)
      end if

      do ivtx = 1, nvtx
        ireo2(ireo(ivtx)) = ivtx
      end do

      ! isuper_tgt: reordered copy of isupervtx_spl
      isuper_tgt(1:nvtx) = isupervtx_spl(ireo2(1:nvtx))
      ! allow reordering of neighbors
      ivtx = 1
      do while(ivtx.lt.nvtx) !ivtx = 1, nvtx
        if (vtxmap(ireo2(ivtx)).gt.0) then
          do jvtx = ivtx+1, nvtx
            if (vtxmap(ireo2(jvtx)).le.0) then
              ivtx = jvtx+1
              exit
            end if
            if (isuper_tgt(jvtx).lt.isuper_tgt(jvtx-1)) then
              ivtx_rem = isuper_tgt(jvtx)
              isuper_tgt(jvtx) = isuper_tgt(jvtx-1)
              kvtx = jvtx-1
              do while(kvtx.gt.ivtx.and.isuper_tgt(kvtx-1).gt.ivtx_rem)
                isuper_tgt(kvtx) = isuper_tgt(kvtx-1)
                kvtx = kvtx-1
              end do
              isuper_tgt(kvtx) = ivtx_rem
            end if
            if (jvtx.eq.nvtx) ivtx=jvtx+1
          end do
        else
          ivtx = ivtx+1
        end if
      end do
      ! fill up zeros / try to add missing target vertices
      ivtx_rem = nj_spl
      do ivtx = nvtx, 1, -1
        if (vtxmap(ireo2(ivtx)).gt.0) then
          if (isuper_tgt(ivtx).eq.0) then
              isuper_tgt(ivtx) = ivtx_rem
              if (ivtx.gt.1.and.ivtx_rem.gt.1.and.
     &            idxlist(ivtx_rem-1,isuper_tgt(1:ivtx-1),
     &                    ivtx-1,1).le.0)
     &           ivtx_rem = ivtx_rem-1
          else
            if (ivtx.gt.1.and.isuper_tgt(ivtx).gt.1.and.
     &          idxlist(isuper_tgt(ivtx)-1,isuper_tgt(1:ivtx-1),
     &                  ivtx-1,1).le.0) then
              ivtx_rem = isuper_tgt(ivtx)-1
            else
              ivtx_rem = isuper_tgt(ivtx)
            end if
          end if
        end if
      end do

      if (sh_sign.ne.1) then
c dbg
c        print *,'sh_sign in split: ',sh_sign
c dbg
        contr_rem%fac = -contr_rem%fac
      end if
c dbg
c      print *,'after approach:'
c      call prt_contr_p(lulog,svertex,vtx,topo,
c     &       xlines,nvtx,nj)
c dbg
c      do ivtx = 1, nvtx
c        list_reo(ivtx) = ireo(list(ivtx))
c      end do

c      ! resort list
c      call unique_list(list_reo,lenlist)
c
c      call topo_merge_vtxs(ireo2,nvtx_rem,nvtx_test,
c     &                     merge_sign,
c     &                     topo,xlines,nvtx,nj,
c     &                     list_reo,lenlist)

c dbg
c      call prt_contr_p(lulog,svertex_spl,vtx_spl,topo_spl,
c     &       xlines_spl,nvtx_spl,nj_spl)
c dbg

      ! one exception for: single vertex, no external lines:
      ! make sure that isupervtx_spl(1) is set
      if (nvtx_spl.eq.1) isupervtx_spl(1) = 1

c      if (ntest.eq.100)
c     &     write(lulog, *) 'vtxmap (new): ',vtxmap
      if (ntest.eq.100)
     &     write(lulog, *) 'ireo: ',ireo
      if (ntest.eq.100)
     &     write(lulog, *) 'ireo2: ',ireo2
      if (ntest.eq.100)
     &     write(lulog, *) 'isupervtx_spl: ',isupervtx_spl

      ! use reo and vtxmap to build ivtx_new
      ! use xlines_spl to set isuper_spl 
      ivtx_rem = 0
      ivtx_spl_last = -1
      isuper_spl_last = -1
      do ivtx = 1, nvtx
        jvtx = ireo2(ivtx)
        if (vtxmap(jvtx).gt.0) then
          if (isuper_tgt(ivtx).gt.isuper_spl_last .and.
     &         isuper_spl_last.ne.0) then
            ivtx_rem = ivtx_rem+1
            ivtx_new(jvtx) = -ivtx_rem
            if (isuper_tgt(ivtx).ne.0)
     &         isuper_spl_last = isuper_tgt(ivtx) !vtxmap(jvtx)
            ivtx_spl_last = ivtx_rem
          else
            ivtx_new(jvtx) = -ivtx_spl_last
          end if
        else
          ivtx_rem = ivtx_rem + 1
          ivtx_new(jvtx) = ivtx_rem
        end if
      end do

      nvtx_rem = ivtx_rem
      if (ntest.eq.100)
     &     write(lulog, *) 'ivtx_new: ',ivtx_new

      ! a bit awkward correction of ivtx_new:
      ! since in topo_approach_vtxs, the interm. vertices are shifted
      ! upwards (if possible), ivtx_new should be 
      ! mainly a decreasing sequence when read backwards
      allocate(ivtx_tmp(nvtx))
      ivtx_tmp(1:nvtx) = ivtx_new(1:nvtx)
      ivtx_rem = nvtx_rem
      do ivtx = nvtx, 1, -1
        if (ivtx_tmp(ireo2(ivtx)).eq.0) cycle
        do jvtx = 1, ivtx
          if (ivtx_tmp(ireo2(jvtx)).eq.ivtx_tmp(ireo2(ivtx))) then
            ivtx_new(ireo2(jvtx)) = sign(ivtx_rem,ivtx_new(ireo2(ivtx)))
            ivtx_tmp(ireo2(jvtx)) = 0
          end if
        end do
        ivtx_rem = ivtx_rem - 1
      end do
      deallocate(ivtx_tmp)
     
      if (ntest.ge.100) then
        write(lulog,*) 'nvtx_rem: ',nvtx_rem
        write(lulog,*) 'ivtx_new (new): ',ivtx_new(1:nvtx)
        write(lulog,*) 'isupervtx_spl: ',isupervtx_spl(1:nvtx)
        write(lulog,*) 'isuper_tgt: ',isuper_tgt(1:nvtx)
        write(lulog,*) 'split_vtxs: ',split_vtxs
      end if
      
      ! loop over arcs of contr and get number of new arcs
      narc_rem  = 0
      do iarc = 1, narc
        ivtx1 = contr%arc(iarc)%link(1)
        ivtx2 = contr%arc(iarc)%link(2)
        if (ivtx_new(ivtx1).lt.0.and.ivtx_new(ivtx2).lt.0) cycle
        narc_rem = narc_rem+1
      end do

      nxarc_rem = nxarc
      do ixarc = 1, nxarc
        ivtx1 = contr%xarc(ixarc)%link(1)
        if (ivtx_new(ivtx1).lt.0) nxarc_rem = nxarc_rem - 1
      end do

      ! resize contr_rem
      call resize_contr(contr_rem,nvtx_rem,narc_rem,nxarc_rem,0)

      contr_rem%nvtx = nvtx_rem
      contr_rem%narc = narc_rem
      contr_rem%nxarc = nxarc_rem

      ! keep this info:
      contr_rem%idx_res = contr%idx_res
      contr_rem%iblk_res = contr%iblk_res

      ! ------------
      ! set vertices
      ! ------------
      do ivtx = 1, nvtx
        ivtx_rem = ivtx_new(ivtx)
        if (ivtx_rem.gt.0) then
          contr_rem%vertex(ivtx_rem) = contr%vertex(ivtx)
          contr_rem%svertex(ivtx_rem) = contr%svertex(ivtx)
        else
          ivtx_rem = -ivtx_rem
          contr_rem%vertex(ivtx_rem)%idx_op = 0
          contr_rem%vertex(ivtx_rem)%iblk_op = 0
          contr_rem%svertex(ivtx_rem) = 100
        end if
      end do

      ! ---------
      ! set arcs
      ! ---------
      iarc_rem = 0
      do iarc = 1, narc
        ivtx1 = contr%arc(iarc)%link(1)
        ivtx2 = contr%arc(iarc)%link(2)
        if (ivtx_new(ivtx1).lt.0.and.ivtx_new(ivtx2).lt.0) cycle
        iarc_rem = iarc_rem+1
        if (iarc_rem.gt.narc_rem)
     &       call quit(1,'split_contr3','na sowas ...!?!')
        if (ivtx_new(ivtx1).gt.0) then
          contr_rem%arc(iarc_rem)%link(1) = ivtx_new(ivtx1)
        else if (.not.split_vtxs) then
          contr_rem%arc(iarc_rem)%link(1) = -isupervtx_spl(ivtx1)
        else
          success = .false.
          do ivtx3 = ivtx1, ivtx2-1
            if (ivtx_new(ivtx3).gt.0) cycle
            ivtx_spl = vtxmap(ivtx1)
            ij = isupervtx_spl(ivtx3)
            occ_x = 0
            icnt = int8_expand(xlines_spl(ivtx_spl,ij),base,occ_x)
            if (iocc_bound('<=',contr%arc(iarc)%occ_cnt,.false.,
     &                     occ_x,.false.)) then
              xlines_spl(ivtx_spl,ij) = xlines_spl(ivtx_spl,ij)
     &                      - topo(ivtx1,ivtx2)
              success = .true.
              exit
            end if
          end do
          if (.not.success) then !call quit(1,'split_contr3','trap (1)')
            ok = .false.
            return
          end if
          contr_rem%arc(iarc_rem)%link(1) = -isupervtx_spl(ivtx3)
        end if
        if (ivtx_new(ivtx2).gt.0) then
          contr_rem%arc(iarc_rem)%link(2) = ivtx_new(ivtx2)
        else if (.not.split_vtxs) then
          contr_rem%arc(iarc_rem)%link(2) = -isupervtx_spl(ivtx2)
        else
          success = .false.
          do ivtx3 = ivtx1+1, ivtx2
            if (ivtx_new(ivtx3).gt.0) cycle
            ivtx_spl = vtxmap(ivtx2)
            ij = isupervtx_spl(ivtx3)
            occ_x = 0
            icnt = int8_expand(xlines_spl(ivtx_spl,ij),base,occ_x)
            if (iocc_bound('<=',contr%arc(iarc)%occ_cnt,.true.,
     &                     occ_x,.false.)) then
              xlines_spl(ivtx_spl,ij) = xlines_spl(ivtx_spl,ij)
     &                      - topo(ivtx2,ivtx1)
              success = .true.
              exit
            end if
          end do
          if (.not.success) then !call quit(1,'split_contr3','trap (2)')
            ok = .false.
            return
          end if
          contr_rem%arc(iarc_rem)%link(2) = -isupervtx_spl(ivtx3)
        end if
        contr_rem%arc(iarc_rem)%occ_cnt = contr%arc(iarc)%occ_cnt
      end do
      if (split_vtxs.and..not.all(xlines_spl.eq.0))
     &     call quit(1,'split_contr3','failed to assign arcs!')

      ! ---------
      ! set xarcs
      ! ---------
      ! copy the remaining xarcs
      ixarc_rem = 0
      do ixarc = 1, nxarc
        ivtx1 = contr%xarc(ixarc)%link(1)
        ivtx2 = contr%xarc(ixarc)%link(2)
        if (ivtx_new(ivtx1).lt.0) cycle
        ixarc_rem = ixarc_rem+1
        if (ixarc_rem.gt.nxarc_rem)
     &       call quit(1,'split_contr3','ja, wie denn ...!?!')
        contr_rem%xarc(ixarc_rem)%link(1) = ivtx_new(ivtx1)
        contr_rem%xarc(ixarc_rem)%link(2) = ivtx2 !?!
        contr_rem%xarc(ixarc_rem)%occ_cnt = contr%xarc(ixarc)%occ_cnt
      end do

      ! add the new xarcs
      do iarc = 1, narc
        ivtx1 = contr%arc(iarc)%link(1)
        ivtx2 = contr%arc(iarc)%link(2)
        if (ivtx_new(ivtx1).eq.0.and.ivtx_new(ivtx2).eq.0) cycle
        if (ivtx_new(ivtx1).ne.0.and.ivtx_new(ivtx2).ne.0) cycle
        ixarc_rem = ixarc_rem+1
        if (ixarc_rem.gt.nxarc_rem)
     &       call quit(1,'split_contr3','ja, was denn ...!?!')
        if (ivtx_new(ivtx1).ne.0) then
          contr_rem%xarc(ixarc_rem)%link(1) = ivtx_new(ivtx1)
          contr_rem%xarc(ixarc_rem)%link(2) = -isupervtx_spl(ivtx2)
          contr_rem%xarc(ixarc_rem)%occ_cnt = contr%arc(iarc)%occ_cnt
        else
          contr_rem%xarc(ixarc_rem)%link(1) = ivtx_new(ivtx2)
          contr_rem%xarc(ixarc_rem)%link(2) = -isupervtx_spl(ivtx1)
          contr_rem%xarc(ixarc_rem)%occ_cnt =
     &         iocc_dagger(contr%arc(iarc)%occ_cnt)
        end if

      end do

      call update_svtx4contr(contr_rem)

      call contr_clean_arcs(contr_rem%arc,contr_rem%narc)
      call arc_sort(contr_rem%arc,contr_rem%narc,contr_rem%nvtx)
      call contr_clean_arcs(contr_rem%xarc,contr_rem%nxarc)
      call arc_sort(contr_rem%xarc,contr_rem%nxarc,contr_rem%nvtx)

      deallocate(topo,topo_spl,vtx,vtx_spl,xlines,xlines_spl,ireo,ireo2,
     &       svertex,svertex_spl,list,ivtx_new,isupervtx_spl,vtxmap,
     &       isuper_tgt)

      if (ntest.ge.100) then
        write(lulog,*) 'final contr_rem:'
        call prt_contr2(lulog,contr_rem,op_info)
      end if

      return
      end
