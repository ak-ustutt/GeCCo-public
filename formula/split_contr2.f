*----------------------------------------------------------------------*
      subroutine split_contr2(new,
     &     contr_rem,contr_spl,contr,op_info)
*----------------------------------------------------------------------*
*     given a contraction contr and a contraction contr_spl (which
*     must be contained in contr, check with contr_in_contr()!),
*     obtain the remainder on contr_rem
*
*     new version: aditional connectivity information is stored via
*      xarcs 
*     more stable identification of the proper sub-contraction
*     (i.pt. if several similar operators are present which only
*      differ by topology)
*
*     note that the contractions should all be in canonical order
*     (automatically, if generated by gen_contrX).
*
*     new: if T the connections to the cut-out fragment have the
*         respective super-vertex number as index
*          if F we use a 0 (as in the old split_contr)
*----------------------------------------------------------------------*
      implicit none

      include 'opdim.h'
      include 'stdunit.h'
      include 'def_contraction.h'
      include 'mdef_operator_info.h'
      include 'ifc_operators.h'

      integer, parameter ::
     &     ntest = 00

      logical, intent(in) ::
     &     new
      type(contraction), intent(in) ::
     &     contr, contr_spl
      type(contraction), intent(out) ::
     &     contr_rem

      type(operator_info), intent(in) ::
     &     op_info

      logical ::
     &     success
      integer ::
     &     nvtx, nvtx_spl, nvtx_rem, ivtx_spl_last, isupervtx_spl_last,
     &     narc, narc_spl, narc_rem,
     &     nxarc,nxarc_spl,nxarc_rem,
     &     ivtx_spl, ivtx_rem, ivtx, ivtx1, ivtx2,
     &     iarc, ixarc, iarc_rem, ixarc_rem, idum, base, base2
      integer, pointer ::
     &     svmap(:), svmap_spl(:), ivtx_new(:), isupervtx_spl(:)
     &     ,topomap(:), occ_vtx(:,:,:), occ_vtx_spl(:,:,:),
     &     topomap_spl(:), vtxinf(:), vtxinf_spl(:), vtxmap(:),
     &     vtxmap2(:)

      integer, external ::
     &     ifndmax, maxblk_in_contr

      if (ntest.ge.100) then
        call write_title(luout,wst_dbg_subr,'split_contr2 at work')
        write(luout,*) 'contr:'
        call prt_contr2(luout,contr,op_info)
        write(luout,*) 'contr_spl:'
        call prt_contr2(luout,contr_spl,op_info)
      end if

      ! prefactor
      if (abs(contr_spl%fac).lt.1d-100)
     &     call quit(1,'split_contr','division by zero encountered')
      contr_rem%fac = contr%fac / contr_spl%fac

      nvtx = contr%nvtx
      nvtx_spl = contr_spl%nvtx
      narc = contr%narc
      narc_spl = contr_spl%narc
      nxarc = contr%nxarc
      nxarc_spl = contr_spl%nxarc

      allocate(svmap_spl(nvtx_spl),svmap(nvtx),ivtx_new(nvtx),
     &     isupervtx_spl(nvtx))
      call svmap4contr2(svmap,contr)
      call svmap4contr2(svmap_spl,contr_spl)

      if (ntest.ge.100) then
        write(luout,*) 'svmap:     ',svmap(1:nvtx)
        write(luout,*) 'svmap_spl: ',svmap_spl(1:nvtx_spl)
      end if

      allocate(occ_vtx(ngastp,2,nvtx),topomap(nvtx*nvtx),
     &         occ_vtx_spl(ngastp,2,nvtx_spl),topomap_spl(nvtx_spl**2),
     &         vtxinf(nvtx),vtxinf_spl(nvtx_spl),vtxmap(nvtx),
     &         vtxmap2(nvtx))

      call occvtx4contr(1,occ_vtx,contr,op_info)
      base = ifndmax(occ_vtx,1,ngastp*2*nvtx,1)+1
      base2 = maxblk_in_contr(contr)
      call occvtx4contr(1,occ_vtx_spl,contr_spl,op_info)
      base = max(base,ifndmax(occ_vtx_spl,1,ngastp*2*nvtx_spl,1)+1)
      base2 = max(base2,maxblk_in_contr(contr_spl))
      call topomap4contr(2,base,base2,
     &     topomap,vtxinf,idum,idum,
     &     contr,occ_vtx)
      call topomap4contr(2,base,base2,
     &     topomap_spl,vtxinf_spl,idum,idum,
     &     contr_spl,occ_vtx_spl)

      if (ntest.ge.100) then
        write(luout,*) 'vtxinf contr:'
        write(luout,*) vtxinf
        write(luout,*) 'topomap contr:'
        call iwrtma(topomap,nvtx,nvtx,nvtx,nvtx)
        write(luout,*) 'vtxinf contr_spl:'
        write(luout,*) vtxinf_spl
        write(luout,*) 'topomap contr_spl:'
        call iwrtma(topomap_spl,nvtx_spl,nvtx_spl,nvtx_spl,nvtx_spl)
      end if

      call identify_vertices(vtxmap, success,
     &                       vtxinf_spl,topomap_spl,nvtx_spl,
     &                       vtxinf,    topomap,    nvtx)

      if (.not.success) then
        write(luout,*) 'vtxinf contr:'
        write(luout,*) vtxinf
        write(luout,*) 'topomap contr:'
        call iwrtma(topomap,nvtx,nvtx,nvtx,nvtx)
        write(luout,*) 'vtxinf contr_spl:'
        write(luout,*) vtxinf_spl
        write(luout,*) 'topomap contr_spl:'
        call iwrtma(topomap_spl,nvtx_spl,nvtx_spl,nvtx_spl,nvtx_spl)
        write(luout, *) 'vtxmap: ',vtxmap
        call quit(1,'split_contr2',
     &     'contrations do not match; check with contr_in_contr() '//
     &     'before call to split_contr2()')
      end if

      if (ntest.eq.100)
     &     write(luout, *) 'vtxmap: ',vtxmap

      ivtx_spl = 0
      vtxmap2 = -1
      do ivtx = 1, nvtx
        if (vtxmap(ivtx).gt.0) then
          ivtx_spl = ivtx_spl+1
          vtxmap2(ivtx) = svmap_spl(ivtx_spl)
        end if
      end do

      call splitmap(ivtx_new,nvtx_rem,
     &     vtxmap2,vtxinf,topomap,nvtx)

      isupervtx_spl = vtxmap2
      do ivtx = 1, nvtx
        isupervtx_spl(ivtx) = max(0,isupervtx_spl(ivtx))
      end do

      if (ntest.ge.100) then
        write(luout,*) 'ivtx_new (new): ',ivtx_new(1:nvtx)
        write(luout,*) 'isupervtx_spl: ',isupervtx_spl(1:nvtx)
      end if
      
      ! loop over arcs of contr and get number of new arcs
      narc_rem  = 0
      do iarc = 1, narc
        ivtx1 = contr%arc(iarc)%link(1)
        ivtx2 = contr%arc(iarc)%link(2)
        if (ivtx_new(ivtx1).lt.0.and.ivtx_new(ivtx2).lt.0) cycle
        narc_rem = narc_rem+1
      end do

      nxarc_rem = nxarc
      do ixarc = 1, nxarc
        ivtx1 = contr%xarc(ixarc)%link(1)
        if (ivtx_new(ivtx1).lt.0) nxarc_rem = nxarc_rem - 1
      end do

      ! resize contr_rem
      call resize_contr(contr_rem,nvtx_rem,narc_rem,nxarc_rem,0)

      contr_rem%nvtx = nvtx_rem
      contr_rem%narc = narc_rem
      contr_rem%nxarc = nxarc_rem

      ! keep this info:
      contr_rem%idx_res = contr%idx_res
      contr_rem%iblk_res = contr%iblk_res

      ! ------------
      ! set vertices
      ! ------------
      do ivtx = 1, nvtx
        ivtx_rem = ivtx_new(ivtx)
        if (ivtx_rem.gt.0) then
          contr_rem%vertex(ivtx_rem) = contr%vertex(ivtx)
          contr_rem%svertex(ivtx_rem) = contr%svertex(ivtx)
        else
          ivtx_rem = -ivtx_rem
          contr_rem%vertex(ivtx_rem)%idx_op = 0
          contr_rem%vertex(ivtx_rem)%iblk_op = 0
          contr_rem%svertex(ivtx_rem) = 100
        end if
      end do

      ! ---------
      ! set arcs
      ! ---------
      iarc_rem = 0
      do iarc = 1, narc
        ivtx1 = contr%arc(iarc)%link(1)
        ivtx2 = contr%arc(iarc)%link(2)
        if (ivtx_new(ivtx1).lt.0.and.ivtx_new(ivtx2).lt.0) cycle
        iarc_rem = iarc_rem+1
        if (iarc_rem.gt.narc_rem)
     &       call quit(1,'split_contr2','na sowas ...!?!')
        if (new) then
          if (ivtx_new(ivtx1).gt.0) then
            contr_rem%arc(iarc_rem)%link(1) = ivtx_new(ivtx1)
          else
            contr_rem%arc(iarc_rem)%link(1) = -isupervtx_spl(ivtx1)
          end if
          if (ivtx_new(ivtx2).gt.0) then
            contr_rem%arc(iarc_rem)%link(2) = ivtx_new(ivtx2)
          else
            contr_rem%arc(iarc_rem)%link(2) = -isupervtx_spl(ivtx2)
          end if
          contr_rem%arc(iarc_rem)%occ_cnt = contr%arc(iarc)%occ_cnt
        else
          contr_rem%arc(iarc_rem)%link(1) = max(0,ivtx_new(ivtx1))
          contr_rem%arc(iarc_rem)%link(2) = max(0,ivtx_new(ivtx2))
          contr_rem%arc(iarc_rem)%occ_cnt = contr%arc(iarc)%occ_cnt
        end if
      end do

      ! ---------
      ! set xarcs
      ! ---------
      ! copy the remaining xarcs
      ixarc_rem = 0
      do ixarc = 1, nxarc
        ivtx1 = contr%xarc(ixarc)%link(1)
        ivtx2 = contr%xarc(ixarc)%link(2)
        if (ivtx_new(ivtx1).lt.0) cycle
        ixarc_rem = ixarc_rem+1
        if (ixarc_rem.gt.nxarc_rem)
     &       call quit(1,'split_contr2','ja, wie denn ...!?!')
        contr_rem%xarc(ixarc_rem)%link(1) = ivtx_new(ivtx1)
        contr_rem%xarc(ixarc_rem)%link(2) = ivtx2 !?!
        contr_rem%xarc(ixarc_rem)%occ_cnt = contr%xarc(ixarc)%occ_cnt
      end do

      ! add the new xarcs
      do iarc = 1, narc
        ivtx1 = contr%arc(iarc)%link(1)
        ivtx2 = contr%arc(iarc)%link(2)
        if (ivtx_new(ivtx1).eq.0.and.ivtx_new(ivtx2).eq.0) cycle
        if (ivtx_new(ivtx1).ne.0.and.ivtx_new(ivtx2).ne.0) cycle
        ixarc_rem = ixarc_rem+1
        if (ixarc_rem.gt.nxarc_rem)
     &       call quit(1,'split_contr2','ja, was denn ...!?!')
        if (ivtx_new(ivtx1).ne.0) then
          contr_rem%xarc(ixarc_rem)%link(1) = ivtx_new(ivtx1)
          contr_rem%xarc(ixarc_rem)%link(2) = -isupervtx_spl(ivtx2)
          contr_rem%xarc(ixarc_rem)%occ_cnt = contr%arc(iarc)%occ_cnt
        else
          contr_rem%xarc(ixarc_rem)%link(1) = ivtx_new(ivtx2)
          contr_rem%xarc(ixarc_rem)%link(2) = -isupervtx_spl(ivtx1)
          contr_rem%xarc(ixarc_rem)%occ_cnt =
     &         iocc_dagger(contr%arc(iarc)%occ_cnt)
        end if

      end do

      call update_svtx4contr(contr_rem)

c      if (.not.new) then ! ???
        call contr_clean_arcs(contr_rem%arc,contr_rem%narc)
        call arc_sort(contr_rem%arc,contr_rem%narc,contr_rem%nvtx)
        call contr_clean_arcs(contr_rem%xarc,contr_rem%nxarc)
        call arc_sort(contr_rem%xarc,contr_rem%nxarc,contr_rem%nvtx)
c      end if

      deallocate(svmap,svmap_spl,ivtx_new, isupervtx_spl)
      deallocate(occ_vtx,topomap,
     &         occ_vtx_spl,topomap_spl,
     &         vtxinf,vtxinf_spl,vtxmap)

      if (ntest.ge.100) then
        write(luout,*) 'final contr_rem:'
        call prt_contr2(luout,contr_rem,op_info)
      end if

      return
      end
