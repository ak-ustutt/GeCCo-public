# ====================================================================
# Module for Python interface with GeCCo
#
# Features: 
# Get orbital information
# Get input information
# Define functions for create targets
#
# Usage:
#  by the GeCCo fortran code:
#   use a system call to run
#   python <python_interface.py> <gecco_input> <orb_info_file>
#   where:
#    <python_interface.py> is the file created by the user, with
#      target definitions
#    <gecco_input> is the main input file for gecco
#    <orb_info_file> is the file generated by the subroutine
#      put_orbinfo (see gecco code), basicaly with the data from
#      the orb_inf variable
#  by the user:
#   see MP2.py as a guide for this interface or follow the
#   comments in the following code.
#
# Yuri, oct 2014
#
import re
import sys
import os

# ====================================================================
# Some general functions and variables
#

# interface script and output names
interface_file_name = sys.argv[0].split('/')
interface_file_name = interface_file_name[ len( interface_file_name)-1]
suffix_out = ".tgt_list"
tgt_list_name = interface_file_name + suffix_out

# In the fortran step, use the following to check for error
msg_error = "Error when creating list: "
msg_final = "Target list generated by: "

# Error: stop and write file with error message
def quit_error( msg):
    f = open( tgt_list_name, 'w')
    f.write( msg_error + msg)
    f.close()
    sys.exit( "Error in Python interface (" + interface_file_name + "): " + msg)

# Needed files
if (len( sys.argv) != 3):
    quit_error("Wrong number of arguments: " + str( sys.argv) + "\n"
               "we need the target file, orbital information and input file.")
gecco_input = sys.argv[1]
orb_info_name = sys.argv[2]

# Check if var is an allowed variable name: starts with a letter
var_regexp = re.compile('^[a-z,A-Z]')
def _is_var( var):
    return var_regexp.match( var)

# ====================================================================
# Class for input information
#
# Usage:
#
# Initialise:
# inp = GeCCo_Input( [<print>])
#
# If the optional argument is passed and it is True, print the input
# information
#
# Get some values from input:
# project = inp.get( 'method.MR.project')
# optref = inp.get( 'calculate.solve.nonlinear.optref')
#
# and so on. For cases with multiple instances of the same keyword,
# we get a list. For instance, an input with
#
# orb_space
#  shell type=occ,def=(5,1,1,0)
#  shell type=closed,def=(3,1,1,0)
#  shell type=frozen,def=(3,0,0,0)
#
# as required in molpro, the commands
#
# shells_types = inp.get( 'orb_space.shell.type')
# shells = inp.get( 'orb_space.shell.def')
#
# will give:
#
# shell_types = [ 'occ', 'closed', 'frozen']
# shell = [ [ 5, 1, 1, 0], [ 3, 1, 1, 0], [3, 0, 0, 0]]
# 
# NOTE: with the current implementation is not possible get default
#       values. If some keyword is needed it must be explicitly in
#       the input.
#
# ====================================================================
# Implementation details:
#
# The information is read from the file gecco_input and stored in the
# dictionary data.
#
#
#
class GeCCo_Input:

    def __init__( self, *print_data):
        if (len( print_data) > 1):
            quit_error('Getting GeCCo input: too much arguments. Pass, optionally, a boolean for printing.')

        self.data = {}

        f = open( gecco_input, 'r')
        input_lines = f.readlines()
        f.close()

        context = ''
        key = ''
        for line in input_lines:
            line = re.findall("^([^#]*)", line)
            line = line[0].strip()
            if (len(line) == 0):
                continue
        
            if (re.search(' |=',line)):
                if (not( context)):
                    quit_error('Getting GeCCo input: context not yet defined.')
                    
                info = line.split(' ')
                key = ''
                if (len( info) > 1):
                    for i in range(0, len(info)-1):
                        key += '.' + info[i]

                args = re.findall('(.+?)=(\(.+\)|[^,]+),?',info[len(info)-1]) # get values and lists

                for a in args:
                    new_key = context + key + '.' + a[0]
                    new_value = a[1]

                    if (re.search('^\(',new_value) and re.search('\)$',new_value)): # get list elements
                        new_value = new_value[1:len(new_value)-1].split(',')
                    
                    if new_key in self.data:
                        if (isinstance( self.data[new_key], list)):
                            self.data[new_key].append( new_value)
                        else:
                            self.data[new_key] = [self.data[new_key], new_value]
                    else:
                        if (isinstance( new_value, list)):
                            self.data[new_key] = [new_value]
                        else:
                            self.data[new_key] = new_value
                
            else:
                context = line

        # Print, if required
        if (len( print_data) == 1):
            if (print_data[0]):
                print "Input information from python interface:"
                for k in self.data:
                    print k + " -> " + str(self.data[k])

    def get( self, arg):
        if arg in self.data:
            return self.data[ arg]
        else:
            quit_error('key ' + arg + ' not found in input.\nNOTE: the python interface can not get default values!')


# ====================================================================
# Class for orbital information
#
# Usage:
#
# Initialise:
# orb_inf = Orb_Info( [<print>])
#
# If the optional argument is passed and it is True, print the input
# information
#
# Get the scalar nsym:
# nsym = orb_inf.get('nsym') 
#
# Get a list:
# nbas = orb_inf.get('nbas')
#
# Get an entry (as in FORTRAN, starting with 1):
# nbas_2 = orb_inf.get('nbas',2)
# ihpvgas_1_2 = orb_inf.get('ihpvgas',1,2)
#
# ====================================================================
# Implementation details:
#
# The informations is stored in a dict of dicts, like:
# nsym : {'dim': 0, 'val': [4], 'len': []}
# nbas : {'dim': 1, 'val': [1, 5, 6, 3], 'len': [4]}
#
# and the file (variable orb_info_name) is in a format like:
# nsym 4
# nbas nsym 1 5 6 3
# ...
# This means: nsym is a scalar, with value 4
#             nbas is an array, with size nsym (must be previously defined) with entries 1 5 6 3
# and so on. 
#
class Orb_Info:
    # TODO: Try some exception handling

    # Initialise class
    def __init__( self, *print_data):
        if (len( print_data) > 1):
            quit_error('Orb_Info: too much arguments. Pass, optionally, a boolean for printing.')

        self.data = {}

        f = open( orb_info_name, 'r')
        for line in f:
            info = line.split()
            if (len(info) < 2):
                quit_error("Orb_Info: missing arguments in orb_inf file.")

            varname = info[0]

            dim = 0
            lengths = []
            for dim_var in info[1:]:
                if (not( _is_var( dim_var))):
                    break
                dim += 1
                if dim_var in self.data:
                    if (self.data[dim_var]['dim'] != 0):
                        quit_error("Orb_Info: Length of an array must be of dimension 0")
                    lengths.append( self.data[dim_var]['val'][0])
                else:
                    quit_error("Orb_Info: Variable not yet defined: " + dim_var)

            prod = 1
            for ilen in range(0, dim):
                prod *= lengths[ilen]
            if(len(info) != prod + 1 + dim):
                quit_error("Orb_Info: Number of elements does not match: " + varname)

            self.data[varname] = {}
            self.data[varname]['dim'] = dim
            self.data[varname]['len'] = lengths
            self.data[varname]['val'] = map(int,info[dim+1:])

        # Print the data
        if (len( print_data) == 1):
            if (print_data[0]):
                print "Orbital information from python interface:"
                for key in self.data:
                    print key, ":", self.data[key]

        return

    # Return the asked element
    def get( self, *args):
        dim = len( args) - 1
        if (dim < 0):
            quit_error("Orb_Info.get: Give at least one argument.")

        var_name = args[0]

        if (dim == 0):
            if (self.data[var_name]['dim'] == 0):
                return self.data[var_name]['val'][0]
            else:
                return self.data[var_name]['val']

        if (dim != self.data[var_name]['dim']):
            quit_error("Orb_Info.get: number of arguments must match the dimension of the variable.")

        pos = 0
        for idim in range(0, dim):
            if (args[idim+1]-1 > self.data[var_name]['len'][idim]):
                quit_error("Orb_Info.get: Array out of range: " + var_name + "\n" +
                           "Asked for " + str( args[1:]) + " but we have " + str( self.data[var_name]['len']))

            prod = 1
            for ilen in range(0, idim):
                prod *= self.data[var_name]['len'][ilen]
            pos += ((args[idim+1]-1)*prod)

        return self.data[var_name]['val'][pos]

# ====================================================================
# Setting targets
#
# Usage:
#
# One should define a new target called <name> by
#
# new_target( <name>, [<required>])
#
# <required> is an optional boolean variable to set if, obviously,
# the target is required. if not given the target is not set to be required.
#
# To add rules and work on the target, the following functions
# are available:
#
# depend( <depend_list>)
# required( [<required>])
# rule( <type>, <args_Dict>)
# 
# The function depend add the targets of the <depend_list> as dependencies
# ATTENTION: Because there is no way (yet) to see if a target from another 
# source (the fortran code, for instance) already exist, THIS FUNCTION DOES
# NOT CHECK IF THE TARGET EXISTS! Take care with this.
#
# The required set the target to be required, unless an False argument is given,
# case where it is set to be non required
#
# rule add a new rule of type <type> and arguments set pairwise in the
# dictionary <args_Dict>. For instance, if you don't know what isa a python dict:
#
# rule("DEF_HAMILTONIAN",
#      {'label':'FOCK','min_rank':1,'max_rank':1,'set_x':'T'}
#
# One can, of course, arrange the informations on the dictionary previously
# and pass it as a variable:
#
# my_args = {'label': 'FOCK'}
# my_args['min_rank'] = 1
# my_args['max_rank'] = 1
# my_args['set_x'] = 'T'
# rule("DEF_HAMILTONIAN",my_args)
#
# or whatsoever.
#
# The above three functions change the contents of the last added target.
# If you want to make changes on an old target (DEFINED IN THE SAME SCRIPT,
# of course) you can use the following function:
#
# modify_target( <name>)
#
# and the changes will affect the target <name>, until a new target is added
# or you call modify_target again.
#
# To debug, one can use the function print_tgt_list(), that will print the 
# informations about the targets up to that point.
#
# After the execution of the script, all targets should be made available to
# GeCCo writing all these informations on disk. This can be done by the function
# export_targets(), and it should be the last statement of the script.
#
#
#=====================================================================
# Implementation details:
#
# This piece of code is quite clear by itself. The targets are stored
# on a list, whose elements are of the class _target
# Because it might be confusing introduce too much OO paradigms to the user,
# There is no emphasis on class functions.
#
# Note on the rules: since there might be different rules of the same type
# in a given target, just a dict will not work without naming the rules.
# They are then stored in a list of lists of name,dict:
#
# [ [<type>, {args}], [<type>, {args}], ... ] 
#

# Containers for target list and current target
#
_target_list = []
_current_tgt = ''

# Class for targets
# 
class _target:

    def __init__( self, name):
        self.name = name
        self.required = False
        self.dependencies = []
        self.joined = []
        self.rules = []

# Function to print list
#
def print_tgt_list():
    print "+=================+"
    print "|   Target list   |"
    print "+=================+"
    for tgt in _target_list:
        print "Name: ", tgt.name
        print "Required: ",tgt.required
        print "Dependencies:"
        for d in tgt.dependencies:
            print d
        print "Rules:"
        for r in tgt.rules:
            print r[0],r[1]
        print "---"

# Add a new target
# 
def new_target( *args):
    global _current_tgt
    if (len( args) == 0):
        quit_error( "new_target: give the target name.")

    name = args[0]
    for tgt in _target_list:
        if (tgt.name == name):
            quit_error( "new_target: target already defined: " + name + ".\n You might use modify_target instead.")

    tgt = _target( name)
    if (len( args) == 2):
        tgt.required = args[1]
    if (len( args) > 2):
        quit_error( "new_target: too much arguments.\n Give just the name and, optionaly, if it is required.")
    _target_list.append( tgt)
    _current_tgt = _target_list[len(_target_list) - 1]

# Modify an existing target
#
def modify_target( name):
    global _current_tgt
    if (len( _target_list) == 0):
        quit_error( "No target yet set.")
    _current_tgt = False
    for tgt in _target_list:
        if (tgt.name == name):
            _current_tgt = tgt
    if (not( _current_tgt)):
        quit_error( "modify_target: target not found: " + name + ".\n You might use new_target instead.")

# Set the target to be required
#
def required( *args):
    if (len( _target_list) == 0):
        quit_error( "No target yet set.")
    if (len( args) == 0):
        _current_tgt.required = True
    else:
        _current_tgt.required = args[0]

# Add dependencies to the targets
#
def depend( *args):
    if (len( _target_list) == 0):
        quit_error( "No target yet set.")
    if (len( args) == 1):
        _current_tgt.dependencies.append( args[0])
    elif (len( args) > 1):
        _current_tgt.dependencies.extend( args)

# Add joined targets to the targets
#
def joinet_with( *args):
    if (len( _target_list) == 0):
        quit_error( "No target yet set.")
    if (len( args) == 1):
        _current_tgt.joined.append( args[0])
    elif (len( args) > 1):
        _current_tgt.joined.extend( args)

# Add a new rule for the current target
#
def rule( rule_type, arguments):
    if (len( _target_list) == 0):
        quit_error( "No target yet set.")
    if (not( isinstance( arguments, dict))):
        quit_error('Error while defining rule ' + str( rule_type) + ". Arguments must be in a dict.")
    _current_tgt.rules.append( [rule_type, arguments])

_list_int_arg = []
_list_label_arg = []
_list_log_arg = []
_list_real_arg = []
_list_str_arg = []

# determine the type of argument and return as a string
#
# How to get val_occ or val_rest ?? We will have to change things in the container.....
def _val_type(a, v):
    rep = v
    if (isinstance( v, list)):
        rep = v[0] 
    if (a in _list_int_arg):
        return 'int'
    if (a in _list_label_arg):
        return 'label'
    if (a in _list_log_arg):
        return 'log'
    if (a in _list_real_arg):
        return 'real'
    if (a in _list_str_arg):
        return 'str'
    if (isinstance( rep, str)):
        return 'label'
    if (isinstance( rep, int)):
        return 'int'
    if (isinstance( rep, float)):
        return 'real'
    quit_error( "Unknown type of argument for " + a + str(v))

# Write targets on disk, to be available by GeCCo
#
def export_targets():

    f = open( tgt_list_name, 'w')

    f.write( msg_final + "Python interface\n")
    for tgt in _target_list:
        f.write( "Name " + tgt.name + "\n")
        f.write( "Required " + str(tgt.required)[0] + "\n")
        f.write( "Dependencies " + str( len( tgt.dependencies)) + "\n")
        for d in tgt.dependencies:
            f.write( str( d) + "\n")
        f.write( "Joined " + str( len( tgt.joined)) + "\n")
        for j in tgt.joined:
            f.write( str( j) + "\n")
        f.write( "Rules " + str( len( tgt.rules)) + "\n")
        for r in tgt.rules:
            f.write( r[0] + " " + str( len( r[1])) + "\n")
            for a in r[1]:
                v = r[1][a]
                v_type = _val_type(a, v)
                narg = 0
                if (isinstance(v, list)):
                    narg = len( v)
                else:
                    narg = 1
                f.write( a + " " + v_type + " " + str(narg) + "\n")
                if (isinstance(v, list)):
                    for v_i in v:
                        if(isinstance(v,bool)):
                            f.write(str(v_i)[0] + "\n")
                        else:
                            f.write(str(v_i) + "\n")
                else:
                    if(isinstance(v,bool)):
                        f.write(str(v)[0] + "\n")
                    else:
                        f.write(str(v) + "\n")

        f.write( "---\n")

    f.close()


# ====================================================================
# Wrappers for rules and variables for arguments
#
# Because it is much more convenient do
#
# DEF_HAMILTONIAN({LABEL:'FOCK',
#                  MIN_RANK:1,
#                  MAX_RANK:1})
#
# then use a lot of quotes in something like
#
# rule('DEF_HAMILTONIAN',{'LABEL':'FOCK',
#                         'MIN_RANK':1,
#                         'MAX_RANK':1}
#
# here are some wraps and variables that make the interface
# more friendly. These are defined dynamically, based on the rules
# names and arguments names in the files indicated below. Let's try
# to make these lists always updated.
#
# Note: It seems to me a nice idea make some conventios to define these
# names... Do we really need OPERATOR and OPERATORS, LABEL_IN
# and LABELS_IN, CA_SYM and CA_SYMMETRY, MIN_BLK and BLK_MIN ...
#

if not( "GECCO_DIR" in os.environ):
    quit_error( "Set the environmental variable GECCO_DIR to the GeCCo location.")

gecco_dir = os.environ["GECCO_DIR"]

# Functions for rules
rules_names_file = gecco_dir + "/interfaces/rules_names.txt"

f = open( rules_names_file, 'r')
rules = f.readlines()
f.close()
rules = map( str.strip, rules)
for r in rules:
    exec ('def ' + r + ' ( arguments):\n\trule("' + r + '", arguments)')

# Variables for arguments
arguments_names_file = gecco_dir + "/interfaces/arguments_names.txt"

f = open( arguments_names_file, 'r')
keywords = f.readlines()
f.close()
keywords = map( str.strip, keywords)
for k in keywords:
    [k_name, k_type] =  k.split()
    if (k_type == 'int'):
        _list_int_arg.append( k_name)
    elif (k_type == 'label'):
        _list_label_arg.append( k_name)
    elif (k_type == 'log'):
        _list_log_arg.append( k_name)
    elif (k_type == 'real'):
        _list_real_arg.append( k_name)
    elif (k_type == 'str'):
        _list_str_arg.append( k_name)
    else:
        quit_error(" Unknown type of argument: " + k_type)

    if k_name in rules:
        print " Warning from Python interface: " + k_name + " is an argument and a rule. Use quotes for this keyword."
    elif (not( re.match("[a-zA-Z_][a-zA-Z0-9_]*", k_name))):
        print " Warning from Python interface: " + k_name + " is not a valid name for a Python variable. Use quotes for this keyword."
    else:
        exec (k_name + ' = "' + k_name + '"')
