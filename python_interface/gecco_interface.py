# ====================================================================
# Module for Python interface with GeCCo
#
# Features: 
# Get orbital information
# Get input information
# Define functions for create targets
#
# Usage:
#  by the GeCCo fortran code:
#   use a system call to run
#   python <python_interface.py> <gecco_input> <orb_info_file>
#   where:
#    <python_interface.py> is the file created by the user, with
#      target definitions
#    <gecco_input> is the main input file for gecco
#    <orb_info_file> is the file generated by the subroutine
#      put_orbinfo (see GeCCo code), basicaly with the data from
#      the orb_inf variable
#  by the user:
#   see MP2.py as a guide for this interface or follow the
#   comments in the following code.
#
# Yuri, oct 2014
#
import re
import sys
import os
import inspect
from gecco_modules.default_keywords import RegistryHandler

# ====================================================================
# Some general functions and variables
#
_script_file_name = sys.argv[0].split('/')
_script_file_name = _script_file_name[len(_script_file_name) - 1]
_suffix_out = ".tgt_list"
_tgt_list_name = _script_file_name + _suffix_out

def quit_error( msg):
    """Error: write file with error message and stops."""
    f = open( _tgt_list_name, 'w')
    f.write( _msg_error + '\n\n' +  msg)
    f.close()
    sys.exit( _script_file_name + ': ' + msg)

def warning( msg):
    """Print a warning message."""
    print (' Warning from ' + _script_file_name + ': ' + msg)

if not( "GECCO_DIR" in os.environ):
    quit_error( "Set the environment variable GECCO_DIR to the GeCCo location.")
_gecco_dir = os.environ["GECCO_DIR"]
_dummy_call = True if (sys.argv[0] == _gecco_dir + '/python_spec/setting_up_python_interface.py') else False

flog = open('log_from_py_'+_script_file_name,'w')
sys.stdout = flog # print statements go to log

# In the fortran step, use the following to check for error
_msg_error = 'Error when creating list: '
_msg_final = 'Target list generated by: '

_msg_error += 'Python Interface (' + _script_file_name + ')'
_msg_final += 'Python Interface (' + _script_file_name + ')'

# Needed files
if (len( sys.argv) != 3):
    quit_error("Wrong number of arguments: " + str( sys.argv) + "\n"
               "we need the target file, orbital information and input file.")
_gecco_input = sys.argv[1]
_orb_info_name = sys.argv[2]

# ====================================================================
# Class for input information
#
# Usage:
#
# Initialise:
# inp = GeCCo_Input( [<print>])
#
# If the optional argument is passed and it is True, print the input
# information
#
# Get some values from input:
# project = inp.get( 'method.MR.project')
# optref = inp.get( 'calculate.solve.nonlinear.optref')
#
# and so on. For cases with multiple instances of the same keyword,
# we get a list. For instance, an input with
#
# orb_space
#  shell type=occ,def=(5,1,1,0)
#  shell type=closed,def=(3,1,1,0)
#  shell type=frozen,def=(3,0,0,0)
#
# as required in molpro, the commands
#
# shells_types = inp.get( 'orb_space.shell.type')
# shells = inp.get( 'orb_space.shell.def')
#
# will give:
#
# shell_types = [ 'occ', 'closed', 'frozen']
# shell = [ [ 5, 1, 1, 0], [ 3, 1, 1, 0], [3, 0, 0, 0]]
# 
# NOTE: with the current implementation is not possible get default
#       values. If some keyword is needed it must be explicitly in
#       the input.
#
# ====================================================================
# Implementation details:
#
# The information is read from the file _gecco_input and stored in the
# dictionary data.
#
#
#

class Keyword(object):
    def __init__(self, name):
        self.name = name
        self.children = {}
        self.arguments = {}

    def add_child(self, keyword):
        if not keyword.name in self.children:
            self.children[keyword.name] = keyword

    def add_argument(self, argument):
        if argument.name in self.arguments:
            self.arguments[argument.name].append(argument)
        else:
            self.arguments[argument.name] = [argument]
 
    def get_child(self, name):
        return self.children[name]

    def get_argument(self, name):
        return self.arguments[name]

class Argument(object):
    def __init__(self, name, value):
        self.name = name
        self.value = self.cast_value(value)
    def cast_value(self, value):
        if value[0] == "(":
            return value[1:-1].split(",")
        else:
            return value

class GeCCoInputParser(object):
    def __init__(self, registry = RegistryHandler() ):
        self._root = Keyword("key_root")
        self._cur_context = [self._root ]
        self._registry = registry

    def parse_line(self,line):
        line = re.match("^([^!]*)",line).group().strip()
        if (len(line) == 0):
            return [],{}
        local_context = []
        arguments = []
        match = re.match('([^ ;=,]+)(?:[ ;]+|$)(.*)',line)
        while ( match is not None and line.strip() != "" ):
            local_context += [Keyword(match.group(1))]
            line = match.group(2)
            match = re.match('([^ ;=,]+)(?:[ ;]+|$)(.*)',line)
        match = re.match('(?P<name>[^=]+)=(?P<value>(?:[^(][^,; ]*|\([^)]+\)))[,; ]*(?P<line>.*)',line)
        while match is not None and line.strip() != "" :
            arguments += [Argument(match.group("name") , match.group("value") )]
            line = match.group("line")
            match = re.match('(?P<name>[^=]+)=(?P<value>(?:[^(][^,; ]*|\([^)]+\)))[,; ]*(?P<line>.*)',line)
        return local_context, arguments
    
    def parse(self, lines):
        for line in lines:
            keywords, arguments = self.parse_line(line)
            self.set_keywords(keywords)
            self.set_arguments(arguments)
        return self._root

    def transform_value(self, value):
        if value[0] == "(":
            return list(value[1:-1].split(","))
        else :
            return value

    def set_arguments(self,arguments):
        keyword = self._cur_context[-1]
        for argument in arguments:
            keyword.add_argument(argument)

        
    def set_keywords(self, keywords):
        if keywords == []:
            return
        for i in xrange(len(self._cur_context),0,-1):
            context_str = ".".join([key.name for key in self._cur_context[1:i]])
            if self._registry.does_exist(context_str, keywords[0].name) :
                self._cur_context = self._cur_context[:i]
                diverged = False
                for keyword in keywords:
                    if not diverged:
                        try:
                            old_keyword = self._cur_context[-1].get_child(keyword.name)
                        except KeyError:
                            diverged = True

                    if not diverged:
                        self._cur_context.append(old_keyword)
                    else:
                        self._cur_context[-1].add_child(keyword)
                        self._cur_context.append(keyword)
                break
        else:
            raise ContextError(
                "{key} not found in {context}".format(
                    key=keywords[0].name,
                    context=".".join(
                        [key.name for key in self._cur_context[1:]]
                    )
                )
            )
 
class GeCCo_Input:

    def __init__( self, do_print=False):
        self.data = {}
        self.env = ''

        with open( _gecco_input, 'r') as f:
            input_lines = f.readlines()
        self.root = GeCCoInputParser().parse(input_lines)

        if (do_print):
            print "-"*50
            print "Input information from python interface:"
            print "TODO!"
            print "-"*50

        # Check the package environment that GeCCo is currently using
        ok=False
        # start with DATON: It does not distinguish between DALTON_64 and DALTON
        if(os.path.isfile('SIRIFC')):
            ok=True
        if(ok and os.path.isfile('MO_G')):
            self.env = 'DALTON_SPECIAL'
        elif(ok and os.path.isfile('MOTWOINT')):
            self.env = 'DALTON'

        # try GAMESS
        if(not ok):
            if(os.path.isfile('DICTNRY')):
                self.env = 'GAMESS'
                ok=True

        # try new MOLPRO interface file
        if(not ok):
            if(os.path.isfile('mpro_gecco_ifc.dat')):
                self.env = 'MOLPRO_IFC'
                ok=True

        # try MOLPRO fci interface
        if(not ok):
            if(os.path.isfile('FCIDUMP')):
                self.env = 'MOLPRO_DUMP'
                ok=True

        # try CFOUR interface file
        if(not ok):
            if(os.path.isfile('cfour_gecco_ifc.dat')):
                self.env = 'CFOUR'
                ok=True

    def is_keyword_set( self, arg):
        keyword = self.root
        context = arg.split(".")
        for name in context:
            try:
                keyword = keyword.get_child(name)
            except KeyError:
                return False
        return True

    def get( self, arg):
        context,arg_name = arg.split(".")[:-1],arg.split(".")[-1]
        keyword = self.root
        for name in context:
            try:
                keyword = keyword.get_child(name)
            except KeyError:
                return None
        try:
            arguments = keyword.get_argument(arg_name)
        except KeyError:
            return None
        else:
            return arguments[0].value if (not
                    isinstance(arguments[0].value,list) and
                    len(arguments) == 1 ) else [argument.value for argument in arguments] 

# ====================================================================
# Class for orbital information
#
# Usage:
#
# Initialise:
# orb_inf = Orb_Info( [<print>])
#
# If the optional argument is passed and it is True, print the input
# information
#
# Get the scalar nsym:
# nsym = orb_inf.get('nsym') 
#
# Get a list:
# nbas = orb_inf.get('nbas')
#
# Get an entry (as in FORTRAN, starting with 1):
# nbas_2 = orb_inf.get('nbas',2)
# ihpvgas_1_2 = orb_inf.get('ihpvgas',1,2)
#
# ====================================================================
# Implementation details:
#
# The informations is stored in a dict of dicts, like:
# nsym : {'dim': 0, 'val': [4], 'len': []}
# nbas : {'dim': 1, 'val': [1, 5, 6, 3], 'len': [4]}
#
# and the file (variable _orb_info_name) is in a format like:
# nsym 4
# nbas nsym 1 5 6 3
# ...
# This means: nsym is a scalar, with value 4
#             nbas is an array, with size nsym (must be previously defined) with entries 1 5 6 3
# and so on. 
#
class Orb_Info:
    # TODO: Try some exception handling

    # Initialise class
    def __init__( self, do_print=False):

        self.data = {}

        f = open( _orb_info_name, 'r')
        for line in f:
            info = line.split()
            if (len(info) < 2):
                quit_error("Orb_Info: missing arguments in orb_inf file.")

            varname = info[0]

            dim = 0
            lengths = []
            for dim_var in info[1:]:
                if (not( re.match('^[a-zA-Z]', dim_var))):
                    break
                dim += 1
                if dim_var in self.data:
                    if (self.data[dim_var]['dim'] != 0):
                        quit_error("Orb_Info: Length of an array must be of dimension 0")
                    lengths.append( self.data[dim_var]['val'][0])
                else:
                    quit_error("Orb_Info: Variable not yet defined: " + dim_var)

            prod = 1
            for ilen in range(0, dim):
                prod *= lengths[ilen]
            if(len(info) != prod + 1 + dim):
                quit_error("Orb_Info: Number of elements does not match: " + varname)

            self.data[varname] = {}
            self.data[varname]['dim'] = dim
            self.data[varname]['len'] = lengths
            self.data[varname]['val'] = map(int,info[dim+1:])

        # Print the data
        if (do_print):
            print "-"*50
            print "Orbital information from python interface:"
            for key in self.data:
                print key, ":", self.data[key]
            print "-"*50

        return

    # Return the asked element
    def get( self, *args):
        dim = len( args) - 1
        if (dim < 0):
            quit_error("Orb_Info.get: Give at least one argument.")

        var_name = args[0]

        if (not( var_name in self.data)):
            quit_error("Orb_Info.get: " + var_name + "is not present in the orbital informations.")
        
        if (dim == 0):
            if (self.data[var_name]['dim'] == 0):
                return self.data[var_name]['val'][0]
            else:
                return self.data[var_name]['val']

        if (dim != self.data[var_name]['dim']):
            quit_error("Orb_Info.get: number of arguments must match the dimension of the variable.")

        pos = 0
        for idim in range(0, dim):
            if (args[idim+1]-1 > self.data[var_name]['len'][idim]):
                quit_error("Orb_Info.get: Array out of range: " + var_name + "\n" +
                           "Asked for " + str( args[1:]) + " but we have " + str( self.data[var_name]['len']))

            prod = 1
            for ilen in range(0, idim):
                prod *= self.data[var_name]['len'][ilen]
            pos += ((args[idim+1]-1)*prod)

        return self.data[var_name]['val'][pos]

# ====================================================================
# Setting targets
#
# Usage:
#
# One should define a new target called <name> by
#
# new_target( <name>, [<required>])
#
# <required> is an optional boolean variable to set if, obviously,
# the target is required. if not given the target is not set to be required.
#
# To add rules and work on the target, the following functions
# are available:
#
# depend( <depend_list>)
# required( [<required>])
# rule( <type>, <args_Dict>)
# 
# The function depend add the targets of the <depend_list> as dependencies
# ATTENTION: Because there is no way (yet) to see if a target from another 
# source (the fortran code, for instance) already exist, THIS FUNCTION DOES
# NOT CHECK IF THE TARGET EXISTS! Take care with this.
#
# The required set the target to be required, unless an False argument is given,
# case where it is set to be non required
#
# rule add a new rule of type <type> and arguments set pairwise in the
# dictionary <args_Dict>. For instance, if you don't know what isa a python dict:
#
# rule("DEF_HAMILTONIAN",
#      {'label':'FOCK','min_rank':1,'max_rank':1,'set_x':'T'}
#
# One can, of course, arrange the informations on the dictionary previously
# and pass it as a variable:
#
# my_args = {'label': 'FOCK'}
# my_args['min_rank'] = 1
# my_args['max_rank'] = 1
# my_args['set_x'] = 'T'
# rule("DEF_HAMILTONIAN",my_args)
#
# or whatsoever.
#
# The above three functions change the contents of the last added target.
# If you want to make changes on an old target (DEFINED IN THE SAME SCRIPT,
# of course) you can use the following function:
#
# modify_target( <name>)
#
# and the changes will affect the target <name>, until a new target is added
# or you call modify_target again.
#
# To debug, one can use the function print_tgt_list(), that will print the 
# informations about the targets up to that point.
#
# After the execution of the script, all targets should be made available to
# GeCCo writing all these informations on disk. This can be done by the function
# export_targets(), and it should be the last statement of the script.
#
#
#=====================================================================
# Implementation details:
#
# This piece of code is quite clear by itself. The targets are stored
# on a list, whose elements are of the class _target
# Because it might be confusing introduce too much OO paradigms to the user,
# There is no emphasis on class functions.
#
# Note on the rules: since there might be different rules of the same type
# in a given target, just a dict will not work without naming the rules.
# They are then stored in a list of lists of name,dict:
#
# [ [<type>, {args}], [<type>, {args}], ... ] 
#

# Containers for target list and current target
#
_target_list = []
_current_tgt = ''

# Class for targets
# 
class _target:
    def __init__( self, name):
        self.name = name
        self.required = False
        self.dependencies = []
        self.joined = []
        self.rules = []
        self.filename = ""
# Function to print list
#
def print_tgt_list():
    print "+=================+"
    print "|   Target list   |"
    print "+=================+"
    for tgt in _target_list:
        print "Name: ", tgt.name
        print "Required: ",tgt.required
        print "Dependencies:"
        for d in tgt.dependencies:
            print d
        print "Rules:"
        for r in tgt.rules:
            print r[0],r[1]
        print "---"

# Add a new target
# 
def new_target( *args):
    global _current_tgt
    if (len( args) == 0):
        quit_error( "new_target: give the target name.")

    name = args[0]
    for tgt in _target_list:
        if (tgt.name == name):
            quit_error( "new_target: target already defined: " + name + ".\n You might use modify_target instead.")

    tgt = _target( name)
    if (len( args) == 2):
        tgt.required = args[1]
    frame = inspect.stack()[1]
    tgt.filename = inspect.getframeinfo(frame[0])[0]
    if (len( args) > 2):
        quit_error( "new_target: too much arguments.\n Give just the name and, optionaly, if it is required.")
    _target_list.append( tgt)
    _current_tgt = _target_list[len(_target_list) - 1]

# Modify an existing target
#
def modify_target( name):
    global _current_tgt
    if (len( _target_list) == 0):
        quit_error( "No target yet set.")
    _current_tgt = False
    for tgt in _target_list:
        if (tgt.name == name):
            _current_tgt = tgt
    if (not( _current_tgt)):
        quit_error( "modify_target: target not found: " + name + ".\n You might use new_target instead.")

# Set the target to be required
#
def required( *args):
    if (len( _target_list) == 0):
        quit_error( "No target yet set.")
    if (len( args) == 0):
        _current_tgt.required = True
    else:
        _current_tgt.required = args[0]

# Add dependencies to the targets
#
def depend( *args):
    if (len( _target_list) == 0):
        quit_error( "No target yet set.")
    if (len( args) == 1):
        _current_tgt.dependencies.append( args[0])
    elif (len( args) > 1):
        _current_tgt.dependencies.extend( args)

# Add joined targets to the targets
#
def joinet_with( *args):
    if (len( _target_list) == 0):
        quit_error( "No target yet set.")
    if (len( args) == 1):
        _current_tgt.joined.append( args[0])
    elif (len( args) > 1):
        _current_tgt.joined.extend( args)

# Add a new rule for the current target
#
def rule( rule_type, arguments):
    if (len( _target_list) == 0):
        quit_error( "No target yet set.")
    if (not( isinstance( arguments, dict))):
        quit_error('Error while defining rule ' + str( rule_type) + ". Arguments must be in a dict.")
    _current_tgt.rules.append( [rule_type, arguments])

_list_int_arg = []
_list_label_arg = []
_list_log_arg = []
_list_real_arg = []
_list_str_arg = []

# determine the type of argument and return as a string
#
# How to get val_occ or val_rest ?? We will have to change things in the container.....
def _val_type(a, v):
    rep = v
    if (isinstance( v, list)):
        rep = v[0] 
    if (a in _list_int_arg):
        return 'int'
    if (a in _list_label_arg):
        return 'label'
    if (a in _list_log_arg):
        return 'log'
    if (a in _list_real_arg):
        return 'real'
    if (a in _list_str_arg):
        return 'str'
    if (isinstance( rep, str)):
        return 'label'
    if (isinstance( rep, int)):
        return 'int'
    if (isinstance( rep, float)):
        return 'real'
    quit_error( "Unknown type of argument for " + a + str(v))

# Write the information on file
def _write_value_on_f( value, f):
    if (isinstance( value, bool)):
        f.write( str( value)[0] + "\n") # T or F
    elif (isinstance( value, float)):
        f.write( repr( value) + "\n")
    else:
        f.write( str( value) + "\n")

# Write targets on disk, to be available by GeCCo
def export_targets():

    flog.close()
    with open( _tgt_list_name, 'w') as f:
        f.write( _msg_final + '\n')
        for tgt in _target_list:
            f.write( "Name " + tgt.name + "\n")
            f.write( "Required " + str(tgt.required)[0] + "\n")
            f.write( "Dependencies " + str( len( tgt.dependencies)) + "\n")
            for d in tgt.dependencies:
                f.write( str( d) + "\n")
            f.write( "Joined " + str( len( tgt.joined)) + "\n")
            for j in tgt.joined:
                f.write( str( j) + "\n")
            f.write( "Rules " + str( len( tgt.rules)) + "\n")
            for r in tgt.rules:
                f.write( r[0] + " " + str( len( r[1])) + "\n")
                for a in r[1]:
                    v = r[1][a]
                    v_type = _val_type(a, v)
                    narg = 0
                    if (isinstance(v, list)):
                        narg = len( v)
                    else:
                        narg = 1
                    f.write( a + " " + v_type + " " + str(narg) + "\n")
                    if (isinstance(v, list)):
                        for v_i in v:
                            _write_value_on_f( v_i, f)
                    else:
                        _write_value_on_f( v, f)
            f.write( "---\n")


# ====================================================================
# Wrappers for rules and variables for arguments
#
# Because it is much more convenient do
#
# DEF_HAMILTONIAN({LABEL:'FOCK',
#                  MIN_RANK:1,
#                  MAX_RANK:1})
#
# then use a lot of quotes in something like
#
# rule('DEF_HAMILTONIAN',{'LABEL':'FOCK',
#                         'MIN_RANK':1,
#                         'MAX_RANK':1}
#
# here are some wraps and variables that make the interface
# more friendly. These are defined dynamically, based on the rules
# names and arguments names in the files indicated below. Let's try
# to make these lists always updated.
#
# Note: It seems to me a nice idea make some conventios to define these
# names... Do we really need OPERATOR and OPERATORS, LABEL_IN
# and LABELS_IN, CA_SYM and CA_SYMMETRY, MIN_BLK and BLK_MIN ...
#

# Functions for rules
_rules_names_file = _gecco_dir + "/python_interface/rules_names.txt"

with open( _rules_names_file, 'r') as f:
    _rules = f.readlines()
_rules = map( str.strip, _rules)
for _r in _rules:
    exec ('def ' + _r + ' ( arguments):\n\trule("' + _r + '", arguments)')

# We want the print level:
_inp = GeCCo_Input()
_print_level = _inp.get('general.print')
if _print_level == None:
    _print_level = 3

# Variables for arguments
_arguments_names_file = _gecco_dir + "/python_interface/arguments_names.txt"

with  open( _arguments_names_file, 'r') as f:
    _keywords = f.readlines()

_keywords = map( str.strip, _keywords)
for _k in _keywords:
    [_k_name, _k_type] =  _k.split()
    if (_k_type == 'int'):
        _list_int_arg.append( _k_name)
    elif (_k_type == 'label'):
        _list_label_arg.append( _k_name)
    elif (_k_type == 'log'):
        _list_log_arg.append( _k_name)
    elif (_k_type == 'real'):
        _list_real_arg.append( _k_name)
    elif (_k_type == 'str'):
        _list_str_arg.append( _k_name)
    else:
        quit_error('Unknown type of argument: ' + _k_type)

    if _k_name in _rules:
        if (_dummy_call and _print_level>=10):
            warning( '"' + _k_name + '" is an argument and a rule. Use quotes for this keyword.')
    elif (not( re.match("[a-zA-Z_][a-zA-Z0-9_]*", _k_name))):
        if (_dummy_call and _print_level>=10):
            warning( '"' + _k_name + '" is not a valid name for a Python variable. Use quotes for this keyword.')
    else:
        exec (_k_name + ' = "' + _k_name + '"')

orbitals=Orb_Info()
keywords=GeCCo_Input()
