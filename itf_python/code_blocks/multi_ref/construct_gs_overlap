---- code("Construct_GS_Overlap")
// Construct overlap blocks of S1 and S2 parts which
// don't involve orthogonalisation to S1 parts

// I1
alloc S1:I1[pq]
load Dm1H[pq]
.S1:I1[pq] := Dm1H[qp]
drop Dm1H[pq]
store S1:I1[pq]

// S0
alloc S1:S0[pq]
load Dm1[pp]
.S1:S0[pq] := Dm1[qp]
drop Dm1[pp]
store S1:S0[pq]

// I2
alloc S2:I2[pqrs]
load Dm2H[pppp]
.S2:I2[pqrs] := Dm2H[qprs]
drop Dm2H[pppp]
store S2:I2[pqrs]

// S2
alloc S2:S2[pq]
load Dm1H[pq]
.S2:S2[pq] := Dm1H[qp]
drop Dm1H[pq]
store S2:S2[pq]

// P0
alloc S2:P0[pqrs]
load Dm2[pppp]
.S2:P0[pqrs] := Dm2[qprs]
drop Dm2[pppp]
store S2:P0[pqrs]

// P1
alloc S2:P1[pq]
load Dm1[pp]
.S2:P1[pq] := Dm1[qp]
drop Dm1[pp]
store S2:P1[pq]

// Construct new preconditioner
alloc Eact[]
load Dm1[pq], g:aa[pq]
.Eact[] += Dm1[pq] g:aa[pq]
drop g:aa[pq], Dm1[pq]
store Eact[]

alloc D1f[pq]
load Dm2[pqrs], g:aa[qs]
.D1f[ps] += Dm2[pqrs] g:aa[qr]
drop g:aa[qs], Dm2[pqrs]
store D1f[pq]

alloc D2f[pqrs]
load Dm3[pqrstu], g:aa[pq]
.D2f[pqtu] += Dm3[pqrstu] g:aa[rs]
drop g:aa[pq], Dm3[pqrstu]
store D2f[pqrs]

// I1 -- TEST: Use Y2:S2 for this case
//alloc Y1:I1[pq]
//load g:aa[rq]
//.Y1:I1[pq] := g:aa[pq]
//drop g:aa[rq]
//store Y1:I1[pq]

// I2
// Factor of 0.25 included here instead of in the transformation
alloc Y2:I2[pqrs]
load Eact[], deltaaa[pr], deltaaa[qs], g:aa[pr], Dm1[qs], D1f[rq], D2f[pqsr], S2:I2[pqts]
.Y2:I2[pqrs] += deltaaa[pr] deltaaa[qs]
element* Y2:I2[pqrs], Eact[]
.Y2:I2[pqrs] -= g:aa[pr] Dm1[qs]
.Y2:I2[pqrs] += 2*g:aa[pr] deltaaa[qs]
alloc I1[pq]
.I1[pq] += g:aa[pr] D1f[rq]
.Y2:I2[pqrs] -= deltaaa[qs] I1[pr]
drop I1[pq]
alloc I1[pq]
.I1[pq] += Dm1[pr] g:aa[rq]
.Y2:I2[pqrs] -= deltaaa[qs] I1[pr]
drop I1[pq]
.Y2:I2[pqrs] -= deltaaa[qs] D1f[pr]
.Y2:I2[pqrs] -= .5*D2f[pqsr]
.Y2:I2[pqrs] += .25*g:aa[rt] S2:I2[pqts]
.Y2:I2[pqrs] += .25*g:aa[pt] S2:I2[rstq]
load Eact[], S2:I2[pqrs]
.Y2:I2[pqrs] -= 0.5*Eact[] S2:I2[pqrs]
drop S2:I2[pqrs], Eact[]
drop S2:I2[pqts], D2f[pqsr], D1f[rq], Dm1[qs], g:aa[pr], deltaaa[qs], deltaaa[pr], Eact[]
store Y2:I2[pqrs]

// S0 -- TEST: Use Y2:P1 for that case
//alloc Y1:S0[pq]
//load g:aa[rq]
//.Y1:S0[pq] := g:aa[pq]
//drop g:aa[rq]
//store Y1:S0[pq]

// S2
alloc Y2:S2[pq]
load Eact[], Dm1[pq], D1f[pq], S2:S2[pr], g:aa[rq]
.Y2:S2[pq] += Eact[] Dm1[pq]
.Y2:S2[pq] -= D1f[pq]
.Y2:S2[pq] += S2:S2[pr] g:aa[rq]
.Y2:S2[pq] -= g:aa[pr] Dm1[rq]
drop g:aa[rq], S2:S2[pr], D1f[pq], Dm1[pq], Eact[]
store Y2:S2[pq]

// TEST: I1 <-- use Y2:S2 for this case
alloc Y1:I1[pq]
load Y2:S2[pq]
.Y1:I1[pq] := Y2:S2[pq]
drop Y2:S2[pq]
store Y1:I1[pq]

// P0
alloc Y2:P0[pqrs]
load D2f[pqrs], Eact[], S2:P0[pqrs]
.Y2:P0[pqrs] += 0.25*D2f[prsq]
.Y2:P0[pqrs] -= Eact[] S2:P0[pqrs]
drop S2:P0[pqrs], Eact[], D2f[pqrs]
store Y2:P0[pqrs]

// P1
alloc Y2:P1[pq]
load D1f[pq], Eact[], S2:P1[pq]
.Y2:P1[pq] += D1f[pq]
.Y2:P1[pq] -= Eact[] S2:P1[pq]
drop S2:P1[pq], Eact[], D1f[pq]
store Y2:P1[pq]

// TEST: S0 <--- use Y2:P1 for that case
alloc Y1:S0[pq]
load Y2:P1[rq]
.Y1:S0[pq] := Y2:P1[pq]
drop Y2:P1[rq]
store Y1:S0[pq]

