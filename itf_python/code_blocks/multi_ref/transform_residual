---- code("Transform_Residual")
// I1
alloc OR:ac[pi]
load R:ac[pi], X1:I1[pq]
.OR:ac[qi] += 2*R:ac[pi] X1:I1[pq]
drop X1:I1[pq], R:ac[pi]
store OR:ac[pi]

alloc OR:aaac[pqri]
load R:aaac[pqri], X2:I1[pqrstu]
.OR:aaac[stui] += R:aaac[pqri] X2:I1[pqrstu]
drop X2:I1[pqrstu], R:aaac[pqri]
store OR:aaac[pqri]

// I2
alloc OR:aacc[pqij]
load R:aacc[pqij], X2:I2[pqrs]
.OR:aacc[rsij] += 2*R:aacc[pqij] X2:I2[pqrs]
drop X2:I2[pqrs], R:aacc[pqij]
store OR:aacc[pqij]

// Transform to pair index K
alloc OR:aacc[Kij], Y2:I2[KJ]
load OR:aacc[pqij], Y2:I2[pqrs], deltap[pqK]
.OR:aacc[Kij] += OR:aacc[pqij] deltap[pqK]
alloc Yi[Krs]
.Yi[Krs] += Y2:I2[pqrs] deltap[pqK]
.Y2:I2[KJ] += Yi[Krs] deltap[rsJ]
drop Yi[Krs]
drop deltap[pqK], Y2:I2[pqrs], OR:aacc[pqij]
store Y2:I2[KJ], OR:aacc[Kij]

// S0
alloc OR:ea[ap]
load R:ea[ap], X1:S0[pq]
.OR:ea[aq] += 2*R:ea[ap] X1:S0[pq]
drop X1:S0[pq], R:ea[ap]
store OR:ea[ap]

alloc OR:eaaa[apqr]
load R:eaaa[apqr], X2:S0[pqrstu]
.OR:eaaa[astu] += R:eaaa[apqr] X2:S0[pqrstu]
drop X2:S0[pqrstu], R:eaaa[apqr]
store OR:eaaa[apqr]

// S1
alloc OR:eaac[apqi]
load R:eaac[apqi], R:eaca[apiq], X2B:S1[pqrs], X4B:S1[pqrs]
.OR:eaac[arsi] += 1.5*R:eaac[apqi] X2B:S1[pqrs]
.OR:eaac[arsi] += 1.5*R:eaca[apiq] X4B:S1[pqrs]
drop X4B:S1[pqrs], X2B:S1[pqrs], R:eaca[apiq], R:eaac[apqi]

// Off-diag orthogonalisation term
load XS12b:S1[rs], R:ec[ai]
.OR:eaac[arsi] += 1.5*XS12b:S1[rs] R:ec[ai]
drop R:ec[ai], XS12b:S1[rs]
store OR:eaac[apqi]

alloc OR:eaca[apiq]
load R:eaca[apiq], R:eaac[apqi], X4A:S1[pqrs], X2A:S1[pqrs]
.OR:eaca[aris] += 1.5*R:eaac[apqi] X4A:S1[pqrs]
.OR:eaca[aris] += 1.5*R:eaca[apiq] X2A:S1[pqrs]
drop X2A:S1[pqrs], X4A:S1[pqrs], R:eaac[apqi], R:eaca[apiq]

// Off-diag orthogonalisation term
load XS12a:S1[rs], R:ec[ai]
.OR:eaca[aris] += 1.5*XS12a:S1[rs] R:ec[ai]
drop R:ec[ai], XS12a:S1[rs]
store OR:eaca[apiq]

// Transporm to pair index K
alloc OR:eaca[aiK], OR:eaac[aiK], YA:S1[KJ], YB:S1[KJ]
load OR:eaca[apiq], OR:eaac[apqi], YA:S1[pqrs], YB:S1[pqrs]
load deltap[pqK]
.OR:eaca[aiK] += OR:eaca[apiq] deltap[pqK]
.OR:eaac[aiK] += OR:eaac[apqi] deltap[pqK]
alloc Yi[Krs]
.Yi[Krs] += YA:S1[pqrs] deltap[pqK]
.YA:S1[KJ] += Yi[Krs] deltap[rsJ]
drop Yi[Krs]
alloc Yi[Krs]
.Yi[Krs] += YB:S1[pqrs] deltap[pqK]
.YB:S1[KJ] += Yi[Krs] deltap[rsJ]
drop Yi[Krs]
drop deltap[pqK]
drop YB:S1[pqrs], YA:S1[pqrs], OR:eaac[apqi], OR:eaca[apiq]
store YB:S1[KJ], YA:S1[KJ], OR:eaac[aiK], OR:eaca[aiK]

// S2
alloc OR:eacc[apij]
load R:eacc[apij], X2:S2[pq]
.OR:eacc[aqij] += 2*R:eacc[apij] X2:S2[pq]
drop X2:S2[pq], R:eacc[apij]
store OR:eacc[apij]

// P0
alloc OR:eeaa[abpq]
load R:eeaa[abpq], X2:P0[pqrs]
.OR:eeaa[abrs] += 2*R:eeaa[abpq] X2:P0[pqrs]
drop X2:P0[pqrs], R:eeaa[abpq]
store OR:eeaa[abpq]

// Transform to pair index K
alloc OR:eeaa[abK], Y2:P0[KJ]
load OR:eeaa[abpq], Y2:P0[pqrs], deltap[pqK]
.OR:eeaa[abK] += OR:eeaa[abpq] deltap[pqK]
alloc Yi[Krs]
.Yi[Krs] += Y2:P0[pqrs] deltap[pqK]
.Y2:P0[KJ] += Yi[Krs] deltap[rsJ]
drop Yi[Krs]
drop deltap[pqK], Y2:P0[pqrs], OR:eeaa[abpq]
store Y2:P0[KJ], OR:eeaa[abK]

// P1
alloc OR:eeac[abpi]
load R:eeac[abpi], X2:P1[pq]
.OR:eeac[abqi] += 2*R:eeac[abpi] X2:P1[pq]
drop X2:P1[pq], R:eeac[abpi]
store OR:eeac[abpi]

