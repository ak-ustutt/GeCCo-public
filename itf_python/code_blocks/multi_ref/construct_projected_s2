---- code("Construct_Projected_S2")
// Set up overlap metric, ready to construct X used
// in sequential orthogonalisation

// I1
alloc S3:I1[pqrs]
load Dm2[pppp], Dm1[pp], deltaaa[pp]
.S3:I1[pqrs] -= Dm2[qprs]
.S3:I1[pqrs] += deltaaa[ps] Dm1[qr]
drop deltaaa[pp], Dm1[pp], Dm2[pppp]
store S3:I1[pqrs]

alloc I1[pqrs], I2[pqrs]
load S1:I1[pq], S3:I1[pqrs]
.I1[pqts] += S3:I1[qpsr] S1:I1[rt]
.I2[pqts] += S3:I1[pqrs] S1:I1[tr]
drop S3:I1[pqrs], S1:I1[pq]
alloc I3[pqrstu]
.I3[pqrstu] += I1[pvst] I2[qrvu]
alloc S2:I1[pqrstu]
load Dm3[pppppp], Dm2[pppp], Dm1[pp], deltaaa[pp]
.S2:I1[pqrstu] := Dm3[rqpstu]
.S2:I1[pqrstu] -= deltaaa[qt] Dm2[rpsu]
.S2:I1[pqrstu] += deltaaa[rt] Dm2[qpsu]
.S2:I1[pqrstu] += deltaaa[qu] Dm2[rpst]
.S2:I1[pqrstu] -= deltaaa[ru] Dm2[qpst]
alloc delta4[pppp]
.delta4[pqtu] += deltaaa[pt] deltaaa[qu]
.S2:I1[pqrstu] += delta4[qrtu] Dm1[sp]
drop delta4[pppp]
.S2:I1[pqrstu] -= I3[pqrstu]
drop deltaaa[pp], Dm1[pp], Dm2[pppp], Dm3[pppppp]
store S2:I1[pqrstu]
drop I3[pqrstu]
drop I2[pqrs], I1[pqrs]

// S0
alloc S3:S0[pqrs]
load Dm2[pppp]
.S3:S0[pqrs] := Dm2[qpsr]
drop Dm2[pppp]
store S3:S0[pqrs]

alloc I1[pqrs], I2[pqrs]
load S1:S0[pq], S3:S0[pqrs]
.I1[pqts] += S3:S0[qpsr] S1:S0[rt]
.I2[pqts] += S3:S0[pqrs] S1:S0[tr]
drop S3:S0[pqrs], S1:S0[pq]
alloc I3[pqrstu]
.I3[pqrstu] += I1[pvst] I2[qrvu]
alloc S2:S0[pqrstu]
load Dm3[pppppp], Dm2[pppp], deltaaa[pp]
.S2:S0[pqrstu] -= Dm3[rqpstu]
.S2:S0[pqrstu] += deltaaa[pu] Dm2[qrst]
drop deltaaa[pp], Dm2[pppp], Dm3[pppppp]
.S2:S0[pqrstu] -= I3[pqrstu]
store S2:S0[pqrstu]
drop I3[pqrstu]
drop I2[pqrs], I1[pqrs]

// S1
alloc S3:S1[pq]
load Dm1[pp]
.S3:S1[pq] := 2*Dm1[qp]
drop Dm1[pp]
store S3:S1[pq]

alloc S3x:S1[pq]
load Dm1[pp]
.S3x:S1[pq] -= Dm1[qp]
drop Dm1[pp]
store S3x:S1[pq]

alloc S2:S1[rpqs]
load Dm2[pppp], Dm1[pp], deltaaa[pp]
.S2:S1[rpqs] -= Dm2[pqrs]
.S2:S1[rpqs] += 2*deltaaa[qr] Dm1[ps]
load S3x:S1[pq]
.S2:S1[rpqs] -= .5*S3x:S1[pr] S3x:S1[qs]
drop S3x:S1[pq]
drop deltaaa[pp], Dm1[pp], Dm2[pppp]
store S2:S1[rpqs]

alloc S2x:S1[rpqs]
load Dm2[pppp], Dm1[pp], deltaaa[pp]
.S2x:S1[rpqs] += 2*Dm2[qprs]
.S2x:S1[rpqs] += 2*deltaaa[qr] Dm1[ps]
load S3:S1[pq]
.S2x:S1[rpqs] -= .5*S3:S1[pr] S3:S1[qs]
drop S3:S1[pq]
drop deltaaa[pp], Dm1[pp], Dm2[pppp]
store S2x:S1[rpqs]

alloc S4:S1[rpqs]
load Dm2[pppp], Dm1[pp], deltaaa[pp]
.S4:S1[rpqs] -= Dm2[qprs]
.S4:S1[rpqs] -= deltaaa[qr] Dm1[ps]
drop deltaaa[pp], Dm1[pp], Dm2[pppp]
load S3:S1[pq], S3x:S1[pq]
.S4:S1[rpqs] -= .5*S3x:S1[pr] S3:S1[qs]
drop S3x:S1[pq], S3:S1[pq]
store S4:S1[rpqs]

alloc S4x:S1[rpqs]
load S4:S1[rpqs]
.S4x:S1[rpqs] += S4:S1[qsrp]
drop S4:S1[rpqs]
store S4x:S1[rpqs]



// Construct preconditoner
alloc Eact[]
load Dm1[pq], g:aa[pq]
.Eact[] += Dm1[pq] g:aa[pq]
drop g:aa[pq], Dm1[pq]
store Eact[]

alloc D1f[pq]
load Dm2[pqrs], g:aa[qs]
.D1f[ps] += Dm2[pqrs] g:aa[qr]
drop g:aa[qs], Dm2[pqrs]
store D1f[pq]

alloc D2f[pqrs]
load Dm3[pqrstu], g:aa[pq]
.D2f[pqtu] += Dm3[pqrstu] g:aa[rs]
drop g:aa[pq], Dm3[pqrstu]
store D2f[pqrs]


// P1
alloc Y2:P1[pq]
load D1f[pq]
.Y2:P1[pq] += D1f[pq]
drop D1f[pq]
store Y2:P1[pq]

// S1
alloc YA:S1[pqrs]
load D1f[pq], D2f[pqrs], Dm1[pq], Dm2[pqru], g:aa[rs], deltaaa[rs]
load S2:S1[pqrs]
.YA:S1[pqrs] += D1f[pr] deltaaa[qs]
.YA:S1[pqrs] += Dm1[pr] g:aa[qs]
.YA:S1[pqrs] += D2f[psrq]
.YA:S1[pqrs] += g:aa[st] Dm2[ptrq]
.YA:S1[pqrs] += Dm2[psrt] g:aa[tq]
// subtract Eact * Overlap (S2x without GS projection)
load Eact[], S3:S1[pr], S2x:S1[pqrs]
// undo GS projection here:
.S2x:S1[pqrs] += .5*S3:S1[pq] S3:S1[rs]
// factor 0.5 as S2x is twice the overlap
.YA:S1[pqrs] -= 0.5*Eact[] S2x:S1[pqrs]
drop S2x:S1[pqrs], S3:S1[pr], Eact[]
drop S2:S1[pqrs]
drop deltaaa[rs], g:aa[rs], Dm2[pqru], Dm1[pq], D2f[pqrs], D1f[pq]
store YA:S1[pqrs]

alloc YB:S1[pqrs]
load D1f[pq], D2f[pqrs], Dm1[pq], Dm2[pqru], g:aa[rs], deltaaa[rs]
.YB:S1[pqrs] += 2*D1f[pr] deltaaa[qs]
.YB:S1[pqrs] += 2*Dm1[pr] g:aa[qs]
.YB:S1[pqrs] -= D2f[psqr]
.YB:S1[pqrs] -= g:aa[st] Dm2[ptqr]
.YB:S1[pqrs] -= Dm2[pstr] g:aa[tq]
// subtract Eact * Overlap (S2x without GS projection)
load Eact[], S3x:S1[pr], S2:S1[pqrs]
// undo GS projection here:
.S2:S1[pqrs] += .5*S3x:S1[pq] S3x:S1[rs]
.YB:S1[pqrs] -= Eact[] S2:S1[pqrs]
drop S2:S1[pqrs], S3x:S1[pq], Eact[]
drop deltaaa[rs], g:aa[rs], Dm2[pqru], Dm1[pq], D2f[pqrs], D1f[pq]
store YB:S1[pqrs]

// Optimised code (ie. fewer contractions)
//alloc YA:S1[pqrs]
//alloc YB:S1[pqrs]
//
//load D1f[pq], deltaaa[qs]
//alloc I1[pqrs]
//.I1[pqrs] += D1f[pr] deltaaa[qs]
//.YA:S1[pqrs] += I1[pqrs]
//.YB:S1[pqrs] += 2*I1[pqrs]
//drop I1[pqrs]
//drop deltaaa[qs], D1f[pq]
//
//load Dm1[pr], g:aa[qs]
//alloc I1[pqrs]
//.I1[pqrs] += Dm1[pr] g:aa[qs]
//.YA:S1[pqrs] += I1[pqrs]
//.YB:S1[pqrs] += 2*I1[pqrs]
//drop I1[pqrs]
//drop g:aa[qs], Dm1[pr]
//
//load D2f[pqrs]
//.YA:S1[pqrs] += D2f[psrq]
//.YB:S1[pqrs] -= D2f[psrq]
//drop D2f[pqrs]
//
//load Dm2[pqru], g:aa[rs]
//alloc I1[pqrs]
//.I1[pqrs] += g:aa[st] Dm2[ptrq]
//.YA:S1[pqrs] += I1[pqrs]
//.YB:S1[pqrs] -= I1[pqrs]
//drop I1[pqrs]
//
//alloc I1[pqrs]
//.I1[pqrs] += Dm2[psrt] g:aa[tq]
//.YA:S1[pqrs] += I1[pqrs]
//.YB:S1[pqrs] -= I1[pqrs]
//drop I1[pqrs]
//drop g:aa[rs], Dm2[pqru]
//
//store YB:S1[pqrs]
//store YA:S1[pqrs]

// S2
//alloc Y2:S2[pq]
//load Dm1[pq], Eact[]
//.Y2:S2[pq] += Eact[] Dm1[pq]
//drop Eact[], Dm1[pq]
//load D1f[pq]
//.Y2:S2[pq] += D1f[pq]
//drop D1f[pq]
//drop Y2:S2[pq]

