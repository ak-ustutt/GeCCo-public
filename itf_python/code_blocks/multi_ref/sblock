---- code("MRCC_SBlock")
// Set up overlap metric, ready to construct X used
// in sequential orthogonalisation

// I1
alloc S1:I1[pq]
load Dm1H[pq]
.S1:I1[pq] := Dm1H[pq]
drop Dm1H[pq]
store S1:I1[pq]

alloc S2:I1[pqrstu]
load Dm3[pppppp], Dm2[pppp], Dm1[pp], deltaaa[pp]
.S2:I1[pqrstu] := Dm3[pqrstu]
.S2:I1[pqrstu] -= deltaaa[pt] Dm2[rqsu]
.S2:I1[pqrstu] += deltaaa[pu] Dm2[rqst]
.S2:I1[pqrstu] += deltaaa[qt] Dm2[rpsu]
.S2:I1[pqrstu] -= deltaaa[qu] Dm2[rpst]
alloc delta4[pppp]
.delta4[pqtu] += deltaaa[pt] deltaaa[qu]
.S2:I1[pqrstu] += delta4[pqtu] Dm1[rs]
.S2:I1[pqrstu] -= delta4[qptu] Dm1[rs]
drop delta4[pppp]
drop deltaaa[pp], Dm1[pp], Dm2[pppp], Dm3[pppppp]
store S2:I1[pqrstu]

alloc S3:I1[pqrs]
load Dm2[pppp], Dm1[pp], deltaaa[pp]
.S3:I1[pqrs] -= Dm2[qprs]
.S3:I1[pqrs] -= deltaaa[pr] Dm1[qs]
.S3:I1[pqrs] += deltaaa[ps] Dm1[qr]
drop deltaaa[pp], Dm1[pp], Dm2[pppp]
store S3:I1[pqrs]

// I2
alloc S2:I2[pqrs]
load Dm2H[pppp]
.S2:I2[pqrs] := Dm2H[pqrs]
drop Dm2H[pppp]
store S2:I2[pqrs]

// S0
alloc S1:S0[pq]
load Dm1[pp]
.S1:S0[pq] := Dm1[pq]
drop Dm1[pp]
store S1:S0[pq]

alloc S2:S0[pqrstu]
load Dm3[pppppp], Dm2[pppp], deltaaa[pp]
.S2:S0[pqrstu] -= Dm3[pqrstu]
.S2:S0[pqrstu] += deltaaa[pu] Dm2[qrst]
drop deltaaa[pp], Dm2[pppp], Dm3[pppppp]
store S2:S0[pqrstu]

alloc S3:S0[pqrs]
load Dm2[pppp]
.S3:S0[pqrs] := Dm2[pqsr]
drop Dm2[pppp]
store S3:S0[pqrs]

// S1
alloc S2:S1[pqrs]
load Dm2[pppp], Dm1[pp], deltaaa[pp]
.S2:S1[pqrs] -= Dm2[qprs]
.S2:S1[pqrs] += deltaaa[ps] Dm1[qr]
drop deltaaa[pp], Dm1[pp], Dm2[pppp]
store S2:S1[pqrs]

alloc S3:S1[pq]
load Dm1[pp]
.S3:S1[pq] := Dm1[qp]
drop Dm1[pp]
store S3:S1[pq]

// S2
alloc S2:S2[pq]
load Dm1H[pq]
.S2:S2[pq] := Dm1H[pq]
drop Dm1H[pq]
store S2:S2[pq]

// P0
alloc S2:P0[pqrs]
load Dm2[pppp]
.S2:P0[pqrs] := Dm2[pqrs]
drop Dm2[pppp]
store S2:P0[pqrs]

// P1
alloc S2:P1[pq]
load Dm1[pp]
.S2:P1[pq] := Dm1[pq]
drop Dm1[pp]
store S2:P1[pq]

